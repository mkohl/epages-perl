.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::SOAP 3"
.TH XML::Compile::SOAP 3 "2017-01-11" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::SOAP \- base\-class for SOAP implementations
.SH "INHERITANCE"
.IX Header "INHERITANCE"
.Vb 3
\& XML::Compile::SOAP is extended by
\&   XML::Compile::SOAP11
\&   XML::Compile::SOAP12
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& ** SOAP1.[12] and WSDL1.1 over HTTP
\&
\& # !!! The next steps are only required when you do not have
\& # !!! a WSDL. See XML::Compile::WSDL11 if you have a WSDL.
\& # !!! Without WSDL file, you need to do a lot manually
\&
\& use XML::Compile::SOAP11::Client;
\& my $client = XML::Compile::SOAP11::Client\->new;
\& $client\->schemas\->importDefinitions(...);
\&
\& use XML::Compile::Util qw/pack_type/;
\& my $h1el = pack_type $myns, $some_element;
\& my $b1el = "{$myns}$other_element";  # same, less clean
\&
\& my $encode_query = $client\->compileMessage
\&   ( \*(AqSENDER\*(Aq
\&   , style    => \*(Aqdocument\*(Aq           # default
\&   , header   => [ h1 => $h1el ]
\&   , body     => [ b1 => $b1el ]
\&   , destination    => [ h1 => \*(AqNEXT\*(Aq ]
\&   , mustUnderstand => \*(Aqh1\*(Aq
\&   );
\&
\& my $decode_response = $client\->compileMessage
\&   ( \*(AqRECEIVER\*(Aq
\&   , header   => [ h2 => $h2el ]
\&   , body     => [ b2 => $b2el ]
\&   , faults   => [ ... ]
\&   );
\&
\& my $transport = XML::Compile::Transport::SOAPHTTP
\&    \->new(address => $server);
\& my $http = $transport\->compileClient(action => ...);
\&
\& my @query    = (h1 => ..., b1 => ...);
\& my $request  = $encode_query\->(@query);
\& my ($response, $trace) = $http\->($request);
\& my $answer   = $decode_response\->($response);
\&
\& use Data::Dumper;
\& warn Dumper $answer;     # discover a HASH with h2 and b2!
\&
\& if($answer\->{Fault}) ... # when an error was reported
\&
\& # Simplify your life: combine above into one call
\& # Also in this case: if you have a WSDL, this is created
\& # for you.   $wsdl\->compileClient(\*(AqMyFirstCall\*(Aq);
\&
\& my $call   = $client\->compileClient
\&   ( kind      => \*(Aqrequest\-response\*(Aq  # default
\&   , name      => \*(AqMyFirstCall\*(Aq
\&   , encode    => $encode_query
\&   , decode    => $decode_response
\&   , transport => $http
\&   );
\&
\& # !!! Usage, with or without WSDL file the same
\&
\& my $result = $call\->(@query)          # SCALAR only the result
\& print $result\->{h2}\->{...};
\& print $result\->{b2}\->{...};
\&
\& my ($result, $trace) = $call\->(...);  # LIST will show trace
\& # $trace is an XML::Compile::SOAP::Trace object
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module handles the \s-1SOAP\s0 protocol.  The first implementation is
\&\s-1SOAP1\s0.1 (\fIhttp://www.w3.org/TR/2000/NOTE\-SOAP\-20000508/\fR), which is still
most often used.  The \s-1SOAP1\s0.2 definition (\fIhttp://www.w3.org/TR/soap12/\fR)
is provided via the separate distribution XML::Compile::SOAP12.
.PP
Be aware that there are three kinds of \s-1SOAP:\s0
.IP "1." 4
Document style (literal) \s-1SOAP\s0, where there is a \s-1WSDL\s0 file which explicitly
types all out-going and incoming messages.  Very easy to use.
.IP "2." 4
\&\s-1RPC\s0 style \s-1SOAP\s0 literal.  The body of the message has an extra element
wrapper, but the content is also well defined.
.IP "3." 4
\&\s-1RPC\s0 style \s-1SOAP\s0 encoded.  The sent data is nowhere described formally.
The data is constructed in some ad-hoc way.
.PP
Don't forget to have a look at the examples in the \fIexamples/\fR directory
included in the distribution.
.PP
Please support my development work by submitting bug-reports, patches
and (if available) a donation.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBnew\fR(%options)" 4
.el .IP "\f(CW$obj\fR\->\fBnew\fR(%options)" 4
.IX Item "$obj->new(%options)"
Create a new \s-1SOAP\s0 object.  You have to instantiate either the \s-1SOAP11\s0 or
\&\s-1SOAP12\s0 sub-class of this, because there are quite some differences (which
can be hidden for you)
.Sp
.Vb 3
\& \-Option    \-\-Default
\&  media_type  application/soap+xml
\&  schemas     created internally
.Ve
.RS 4
.IP "media_type => \s-1MIMETYPE\s0" 2
.IX Item "media_type => MIMETYPE"
.PD 0
.ie n .IP "schemas => ""XML::Compile::Cache"" object" 2
.el .IP "schemas => \f(CWXML::Compile::Cache\fR object" 2
.IX Item "schemas => XML::Compile::Cache object"
.PD
Use this when you have already processed some schema definitions.  Otherwise,
you can add schemas later with \f(CW\*(C`$soap\->schemas\->importDefinitions()\*(C'\fR
The Cache object must have \f(CW\*(C`any_element\*(C'\fR and \f(CW\*(C`any_attribute\*(C'\fR set to
\&\f(CW\*(AqATTEMPT\*(Aq\fR
.RE
.RS 4
.RE
.ie n .IP "XML::Compile::SOAP\->\fBregister\fR($uri, $envns)" 4
.el .IP "XML::Compile::SOAP\->\fBregister\fR($uri, \f(CW$envns\fR)" 4
.IX Item "XML::Compile::SOAP->register($uri, $envns)"
Declare an operation type, being an (\s-1WSDL\s0 specific) \f(CW$uri\fR and envelope
namespace.
.SS "Accessors"
.IX Subsection "Accessors"
.ie n .IP "$obj\->\fBmediaType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBmediaType\fR()" 4
.IX Item "$obj->mediaType()"
.PD 0
.ie n .IP "$obj\->\fBschemas\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBschemas\fR()" 4
.IX Item "$obj->schemas()"
.PD
Returns the XML::Compile::Cache object which contains the
knowledge about the types.
.ie n .IP "$obj\->\fBversion\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBversion\fR()" 4
.IX Item "$obj->version()"
.SS "Single message"
.IX Subsection "Single message"
.PD 0
.ie n .IP "$obj\->\fBcompileMessage\fR( <'\s-1SENDER\s0'|'\s-1RECEIVER\s0'>, %options )" 4
.el .IP "\f(CW$obj\fR\->\fBcompileMessage\fR( <'\s-1SENDER\s0'|'\s-1RECEIVER\s0'>, \f(CW%options\fR )" 4
.IX Item "$obj->compileMessage( <'SENDER'|'RECEIVER'>, %options )"
.PD
The payload is defined explicitly, where all headers and bodies are
described in detail.  When you have a \s-1WSDL\s0 file, these \s-1ENTRIES\s0 are
generated automatically, but can be modified and extended (\s-1WSDL\s0 files
are often incomplete)
.Sp
To make your life easy, the \s-1ENTRIES\s0 use a label (a free to choose key,
the \fIpart name\fR in \s-1WSDL\s0 terminology), to ease relation of your data with
the type where it belongs to.  The element of an entry (the value) is
defined as an \f(CW\*(C`any\*(C'\fR element in the schema, and therefore you will need
to explicitly specify the element to be processed.
.Sp
As \f(CW%options\fR, you can specify any listed here, but also anything which is
accepted by \fIXML::Compile::Schema::compile()\fR, like
\&\f(CW\*(C`sloppy_integers => 1\*(C'\fR and hooks.  These are applied to all header
and body elements (not to the \s-1SOAP\s0 wrappers)
.Sp
.Vb 9
\& \-Option        \-\-Default
\&  body            []
\&  destination     []
\&  faults          []
\&  header          undef
\&  mustUnderstand  []
\&  procedure       undef
\&  role            ULTIMATE
\&  roles           []
.Ve
.RS 4
.IP "body => ENTRIES|HASH" 2
.IX Item "body => ENTRIES|HASH"
\&\s-1ARRAY\s0 of \s-1PAIRS\s0, defining a nice \s-1LABEL\s0 (free of choice but unique, also
w.r.t. the header and fault \s-1ENTRIES\s0) and an element type name or \s-1CODE\s0
reference.  The \s-1LABEL\s0 will appear in the Perl \s-1HASH\s0 only, to be able to
refer to a body element in a simple way.
.IP "destination => ARRAY-OF-PAIRS" 2
.IX Item "destination => ARRAY-OF-PAIRS"
Writers only.  Indicate who the target of the header entry is.
By default, the end-point is the destination of each header element.
.Sp
The \s-1ARRAY\s0 contains a \s-1LIST\s0 of key-value pairs, specifying an entry label
followed by an \fIactor\fR (soap1.1) or \fIrole\fR (soap1.2) \s-1URI\s0.  You may use
the predefined actors/roles, like '\s-1NEXT\s0'.  See \fIroleURI()\fR and
\&\fIroleAbbreviation()\fR.
.IP "faults => ENTRIES|HASH" 2
.IX Item "faults => ENTRIES|HASH"
The \s-1SOAP1\s0.1 and \s-1SOAP1\s0.2 protocols define fault entries in the
answer.  Both have a location to add your own additional
information: the type(\-processor) is to specified here, but the
returned information structure is larger and differs per \s-1SOAP\s0
implementation.
.IP "header => ENTRIES|HASH" 2
.IX Item "header => ENTRIES|HASH"
\&\s-1ARRAY\s0 of \s-1PAIRS\s0, defining a nice \s-1LABEL\s0 (free of choice but unique)
and an element type name.  The \s-1LABEL\s0 will appear in the Perl \s-1HASH\s0, to
refer to the element in a simple way.
.Sp
The element type is used to construct a reader or writer.  You may also
create your own reader or writer, and then pass a compatible \s-1CODE\s0 reference.
.IP "mustUnderstand => STRING|ARRAY\-OF\-STRING" 2
.IX Item "mustUnderstand => STRING|ARRAY-OF-STRING"
Writers only.  The specified header entry labels specify which elements
must be understood by the destination.  These elements will get the
\&\f(CW\*(C`mustUnderstand\*(C'\fR attribute set to \f(CW1\fR (soap1.1) or \f(CW\*(C`true\*(C'\fR (soap1.2).
.IP "procedure => \s-1TYPE\s0" 2
.IX Item "procedure => TYPE"
Required in rpc style, when there is no \f(CW\*(C`body\*(C'\fR which contains the
procedure name (when the \s-1RPC\s0 info does not come from a \s-1WSDL\s0)
.IP "role => URI|ARRAY\-OF\-URI" 2
.IX Item "role => URI|ARRAY-OF-URI"
Readers only.
One or more URIs, specifying the role(s) you application has in the
process.  Only when your role contains \f(CW\*(C`ULTIMATE\*(C'\fR, the body is
parsed.  Otherwise, the body is returned as uninterpreted \s-1XML\s0 tree.
You should not use the role \f(CW\*(C`NEXT\*(C'\fR, because every intermediate
node is a \f(CW\*(C`NEXT\*(C'\fR.
.Sp
All understood headers are parsed when the \f(CW\*(C`actor\*(C'\fR (soap1.1) or
\&\f(CW\*(C`role\*(C'\fR (soap1.2) attribute address the specified \s-1URI\s0.  When other
headers emerge which are not understood but carry the \f(CW\*(C`mustUnderstood\*(C'\fR
attribute, an fault is returned automatically.  In that case, the
call to the compiled subroutine will return \f(CW\*(C`undef\*(C'\fR.
.IP "roles => ARRAY-OF-URI" 2
.IX Item "roles => ARRAY-OF-URI"
Alternative for option \f(CW\*(C`role\*(C'\fR
.RE
.RS 4
.RE
.ie n .IP "$obj\->\fBmessageStructure\fR($xml)" 4
.el .IP "\f(CW$obj\fR\->\fBmessageStructure\fR($xml)" 4
.IX Item "$obj->messageStructure($xml)"
.PD 0
.IP "XML::Compile::SOAP\->\fBmessageStructure\fR($xml)" 4
.IX Item "XML::Compile::SOAP->messageStructure($xml)"
.PD
Returns a \s-1HASH\s0 with some collected information from a complete \s-1SOAP\s0
message (XML::LibXML::Document or XML::LibXML::Element).  Currenty,
the \s-1HASH\s0 contains a \f(CW\*(C`header\*(C'\fR and a \f(CW\*(C`body\*(C'\fR key, with each an \s-1ARRAY\s0
of element names which where found in the header resp. body.
.SS "Helpers"
.IX Subsection "Helpers"
.SS "Transcoding"
.IX Subsection "Transcoding"
.ie n .IP "$obj\->\fBreplyMustUnderstandFault\fR($type)" 4
.el .IP "\f(CW$obj\fR\->\fBreplyMustUnderstandFault\fR($type)" 4
.IX Item "$obj->replyMustUnderstandFault($type)"
Produce an error structure to be returned to the sender.
.ie n .IP "$obj\->\fBroleAbbreviation\fR($uri)" 4
.el .IP "\f(CW$obj\fR\->\fBroleAbbreviation\fR($uri)" 4
.IX Item "$obj->roleAbbreviation($uri)"
Translate a role \f(CW$uri\fR into a simple string, if predefined.  See
\&\fIroleURI()\fR.
.ie n .IP "$obj\->\fBroleURI\fR($uri|STRING)" 4
.el .IP "\f(CW$obj\fR\->\fBroleURI\fR($uri|STRING)" 4
.IX Item "$obj->roleURI($uri|STRING)"
Translates actor/role/destination abbreviations into URIs. Various
\&\s-1SOAP\s0 protocol versions have different pre-defined STRINGs, which can
be abbreviated for readibility.  Returns the unmodified \f(CW$uri\fR in
all other cases.
.Sp
\&\s-1SOAP11\s0 only defines \f(CW\*(C`NEXT\*(C'\fR.  \s-1SOAP12\s0 defines \f(CW\*(C`NEXT\*(C'\fR, \f(CW\*(C`NONE\*(C'\fR, and
\&\f(CW\*(C`ULTIMATE\*(C'\fR.
.SH "DETAILS"
.IX Header "DETAILS"
.SS "\s-1SOAP\s0 introduction"
.IX Subsection "SOAP introduction"
Although the specifications of \s-1SOAP1\s0.1 and \s-1WSDL1\s0.1 are thin, the number
of special constructs are many. And, of course, all are poorly documented.
\&\s-1SOAP\s0 1.2 has a much better specification, but is not used a lot.  I have
not seen \s-1WSDL2\s0 in real life.
.PP
\&\s-1WSDL\s0 defines two kinds of messages: \fBdocument\fR style \s-1SOAP\s0 and \fBrpc\fR
style \s-1SOAP\s0.  In document style \s-1SOAP\s0, the messages are described in
great detail in the \s-1WSDL:\s0 the message components are all defined in
Schema's. The worst things you can (will) encounter are \f(CW\*(C`any\*(C'\fR schema
elements which require additional manual processing.
.PP
\&\f(CW\*(C`RPC Literal\*(C'\fR behaves very much the same way as document style soap,
but has one extra wrapper inside the Body of the message.
.PP
\&\f(CW\*(C`Encoded SOAP\-RPC\*(C'\fR, however, is a very different ball-game.  It is simple
to use with strongly typed languages, to exchange data when you create both
the client software and the server software.  You can simply autogenerate
the data encoding.  Clients written by third parties have to find the
documentation on how to use the encoded  \s-1RPC\s0 call in some other way... in
text, if they are lucky; the \s-1WSDL\s0 file does not contain the prototype
of the procedures, but that doesn't mean that they are free-format.
.PP
\&\fBEncoded \s-1RPC\s0\fR messages are shaped to the procedures which are
being called on the server.  The body of the sent message contains the
ordered list of parameters to be passed as 'in' and 'in/out' values to the
remote procedure.  The body of the returned message lists the result value
of the procedure, followed by the ordered 'out' and 'in/out' parameters.
.SS "Supported servers"
.IX Subsection "Supported servers"
Only the commercial hype speaks about \s-1SOAP\s0 in very positive words.
However, the \*(L"industry quality\*(R" of these modern \*(L"technologies\*(R" clearly
demonstrates the lack of education and experience most programmers and
designers have.  This is clearly visible in many, many bugs you will
encounter when working with schemas and WSDLs.
.PP
Interoperability of \s-1SOAP\s0 clients and servers is more \*(L"trial and error\*(R"
and \*(L"manually fixing\*(R" than it should be.  For instance, a server may
report internal server errors back to the client... but a \s-1WSDL\s0 does not
tell you which namespace/schema is used for these errors.  Both \s-1BEA\s0 and
SharePoint servers produce illegal \s-1SOAP\s0 responses!  It is a sad story.
.PP
To be able to install some fixes, you can specify a server type via
XML::Compile::SOAP::Operation::new(server_type),
XML::Compile::WSDL11::new(server_type), or
[3.06] XML::Compile::WSDL11::operations(server_type).
.PP
The following server types are currently understood:
.IP "\(bu" 4
\&\f(CW\*(C`BEA\*(C'\fR, Oracle
.IP "\(bu" 4
\&\f(CW\*(C`SharePoint\*(C'\fR, MicroSoft
.IP "\(bu" 4
\&\f(CW\*(C`XML::Compile::Daemon\*(C'\fR
.PP
Examples:
.PP
.Vb 3
\&  my $wsdl = XML::Compile::WSDL11\->new($wsdlfn, server_type => \*(AqSharePoint\*(Aq);
\&  my $op   = XML::Compile::SOAP11::Operation\->new(..., server_type => \*(AqBEA\*(Aq);
\&  my @op   = XML::Compile::WSDL11\->operations(server_type => \*(AqSharePoint\*(Aq)
.Ve
.PP
[3.17] \fBBe warned:\fR the licenses of some server_type schema's are unknown
or unclear.  At least, they touch commercial products hence can better
not be released in a (Debian) Linux distribution, even not as non-free.
Therefore, you need to install XML::Compile::Licensed from \s-1CPAN\s0
yourself.
.SS "Naming types and elements"
.IX Subsection "Naming types and elements"
\&\s-1XML\s0 uses namespaces: URIs which are used as constants, grouping a set
of type and element definitions.  By using name-spaces, you can avoid
name clashes, which have frustrated many projects in the past when they
grew over a certain size... at a certain size, it becomes too hard to
think of good distinguishable names.  In such case, you must be happy
when you can place those names in a context, and use the same naming in
separate contexts without confusion.
.PP
That being said: \s-1XML\s0 supports both namespace\- and non-namespace elements
and schema's; and of cause many mixed cases.  It is by far preferred to
use namespace schemas only. In a schema \s-1XSD\s0 file, look for the
\&\f(CW\*(C`targetNamespace\*(C'\fR attribute of the \f(CW\*(C`schema\*(C'\fR element: if present, it
uses namespaces.
.PP
In \s-1XML\s0 data, it is seen as a hassle to write the full length of the \s-1URI\s0
each time that a namespace is addressed.  For this reason, prefixes are
used as abbreviations for the namespace \s-1URI\s0.  In programs, you can simply
assign short variable names to long URIs, so we do not need that trick.
.PP
Within your program, you use
.PP
.Vb 2
\&  $MYSN = \*(Aqlong URI of namespace\*(Aq;
\&  ... $type => "{$MYNS}typename" ...
.Ve
.PP
or nicer
.PP
.Vb 3
\&  use XML::Compile::Util qw/pack_type/;
\&  use constant MYNS => \*(Aqsome uri\*(Aq;
\&  ... $type => pack_type(MYNS, \*(Aqtypename\*(Aq) ...
.Ve
.PP
The XML::Compile::Util module provides a helpful methods and constants,
as does the XML::Compile::SOAP::Util.
.SS "Client and Server implementations"
.IX Subsection "Client and Server implementations"
To learn how to create clients in \s-1SOAP\s0, read the \s-1DETAILS\s0 section in
XML::Compile::SOAP::Client.  The client implementation is platform
independent.
.PP
Servers can be created with the external XML::Compile::SOAP::Daemon
distribution. Those servers are based on Net::Server. Can be used
to create a test-server in a few minutes... or production server.
.PP
Don't forget to have a look at the examples in the \fIexamples/\fR directory
included in the distribution.
.SS "Use of wildcards (any and anyAttribute)"
.IX Subsection "Use of wildcards (any and anyAttribute)"
Start reading about wildcards in XML::Compile. When you receive a
message which contains \*(L"\s-1ANY\s0\*(R" elements, an attempt will be made to decode
it automatically. Sending messages which contain \*(L"\s-1ANY\s0\*(R" fields is
harder... you may try hooks or something more along these lines:
.PP
.Vb 4
\&   my $doc = XML::LibXML::Document\->new(\*(Aq1.0\*(Aq, \*(AqUTF\-8\*(Aq);
\&   my $type    = pack_type $ns, $local;
\&   my $node    = $wsdl\->writer($type)\->($doc, $value);
\&   my $message = { ..., $type => $node };
\&
\&   my $call = $wsdl\->compileClient(\*(AqmyOpToCall\*(Aq);
\&   my ($answer, $trace) = $call\->(_doc => $doc, message => $message);
.Ve
.PP
Here, \f(CW$type\fR is the type of the element which needs to be filled in
on a spot where the schema defines an \*(L"\s-1ANY\s0\*(R" element. You need to include
the full typename as key in the \s-1HASH\s0 (on the right spot) and a fully
prepared \f(CW$node\fR, an XML::LibXML::Element, as the value.
.PP
You see that the \f(CW$doc\fR which is created to produce the special node
in the message is also passed to the \f(CW$call\fR. The call produces the
message which is sent and needs to use the same document object as the
node inside it. The chances are that when you forget to pass the \f(CW$doc\fR
it still works... but you may get into characterset problems and such.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile-SOAP distribution version 3.21,
built on January 11, 2017. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2007\-2017 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
