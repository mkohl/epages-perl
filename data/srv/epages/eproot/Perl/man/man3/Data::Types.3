.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Types 3"
.TH Data::Types 3 "2013-12-16" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Types \- Validate and convert data types.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Data::Types qw(:all);
\&
\&  my $whole = 4.5;
\&  $whole = to_whole($whole) unless is_whole($whole);
\&
\&  my $int = 1.2;
\&  $int = to_int($int) unless is_int($int);
\&
\&  my $decimal = \*(Aq1.2foo\*(Aq;
\&  $decimal = to_decimal($decimal) unless is_decimal($decimal);
\&
\&  my $real = \*(Aq1.2foo\*(Aq;
\&  $real = to_real($real) unless is_real($real);
\&
\&  my $float = \*(Aq1.2foo\*(Aq;
\&  $float = to_float($float) unless is_float($float);
\&
\&  my $string = [];
\&  $string = to_string($string) unless is_string($string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module exports a number of functions that are useful for validating and
converting data types. It is intended for use in applications where data types
are more important than they typically are in Perl \*(-- e.g., database
applications.
.SH "EXPORT"
.IX Header "EXPORT"
No functions are exported by default, though each function may be exported
explicitly (see \*(L"Functions\*(R", below, for a list of functions available for
export). The following export tags are supported:
.IP ":whole" 4
.IX Item ":whole"
Exports \fIis_whole()\fR and \fIto_whole()\fR.
.IP ":count" 4
.IX Item ":count"
Exports \fIis_count()\fR and \fIto_count()\fR.
.IP ":int" 4
.IX Item ":int"
Exports \fIis_int()\fR and \fIto_int()\fR.
.IP ":decimal" 4
.IX Item ":decimal"
Exports \fIis_decimal()\fR and \fIto_decimal()\fR.
.IP ":real" 4
.IX Item ":real"
Exports \fIis_real()\fR and \fIto_real()\fR.
.IP ":float" 4
.IX Item ":float"
Exports \fIis_float()\fR and \fIto_float()\fR.
.IP ":string" 4
.IX Item ":string"
Exports \fIis_string()\fR and \fIto_string()\fR.
.IP ":is" 4
.IX Item ":is"
Exports all validation functions: \fIis_whole()\fR, \fIis_int()\fR, \fIis_real()\fR, \fIis_decimal()\fR,
\&\fIis_float()\fR, and \fIis_string()\fR.
.IP ":to" 4
.IX Item ":to"
Exports all conversion functions: \fIto_whole()\fR, \fIto_int()\fR, \fIto_real()\fR, \fIto_decimal()\fR,
\&\fIto_float()\fR, and \fIto_string()\fR.
.IP ":all" 4
.IX Item ":all"
Exports all functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.SS "is_whole"
.IX Subsection "is_whole"
.Vb 1
\&  my $bool = is_whole($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a whole number (including 0), and false if it is not.
The regular expression used to test the wholeness of \f(CW$val\fR is \f(CW\*(C`/^\ed+$/\*(C'\fR.
.PP
.Vb 3
\&  my $bool = is_whole(1); # Returns true.
\&  $bool = is_whole(\-1);   # Returns false.
\&  $bool = is_whole(0);    # Returns true.
.Ve
.SS "to_whole"
.IX Subsection "to_whole"
.Vb 1
\&  my $whole = to_whole($val);
.Ve
.PP
Converts \f(CW$val\fR to a whole number and returns it. Numbers will be rounded to the
nearest whole. If \f(CW$val\fR is a mixture of numbers and letters, \fIto_whole()\fR will
extract the first decimal number it finds and convert that number to a whole
number.
.PP
.Vb 6
\&  my $whole = to_whole(10);     # Returns 10.
\&  $whole = to_whole(0);         # Returns 0.
\&  $whole = to_whole(.22);       # Returns 0.
\&  $whole = to_whole(\-2);        # Returns undef.
\&  $whole = to_whole(\*(Aqfoo3.56\*(Aq); # Returns 4.
\&  $whole = to_whole(\*(Aqfoo\*(Aq);     # Returns undef.
.Ve
.SS "is_count"
.IX Subsection "is_count"
.Vb 1
\&  my $bool = is_count($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a counting number (1, 2, 3, ...), and false if it is
not. The regular expression used to test whether \f(CW$val\fR is a counting number is
\&\f(CW\*(C`/^\ed+$/\*(C'\fR.
.PP
.Vb 3
\&  my $bool = is_count(1); # Returns true.
\&  $bool = is_count(\-1);   # Returns false.
\&  $bool = is_count(0);    # Returns false.
.Ve
.SS "to_count"
.IX Subsection "to_count"
.Vb 1
\&  my $count = to_count($val);
.Ve
.PP
Converts \f(CW$val\fR to a counting number and returns it. Numbers will be rounded to
the nearest counting number. Note that since 0 (zero) is not considered a
counting number by this module, it will not be returned. If \f(CW$val\fR is a mixture
of numbers and letters, \fIto_count()\fR will extract the first decimal number it
finds and convert that number to a counting number.
.PP
.Vb 6
\&  my $count = to_count(10);     # Returns 10.
\&  $count = to_count(0);         # Returns undef.
\&  $count = to_count(.22);       # Returns undef (rounded down to 0).
\&  $count = to_count(\-2);        # Returns undef.
\&  $count = to_count(\*(Aqfoo3.56\*(Aq); # Returns 4.
\&  $count = to_count(\*(Aqfoo\*(Aq);     # Returns undef.
.Ve
.SS "is_int"
.IX Subsection "is_int"
.Vb 1
\&  my $bool = is_int($val);
.Ve
.PP
Returns true if \f(CW$val\fR is an integer, and false if it is not. Numbers may be
preceded by a plus or minus sign. The regular expression used to test for an
integer in \f(CW$val\fR is \f(CW\*(C`/^[+\-]?\ed+$/\*(C'\fR.
.PP
.Vb 4
\&  my $bool = is_int(0); # Returns true.
\&  $bool = is_int(22);   # Returns true.
\&  $bool = is_int(\-22);  # Returns false.
\&  $bool = is_int(3.2);  # Returns false.
.Ve
.SS "to_int"
.IX Subsection "to_int"
.Vb 1
\&  my $int = to_int($val);
.Ve
.PP
Converts \f(CW$val\fR to an integer. If \f(CW$val\fR is a decimal number, it will be rounded to
the nearest integer. If \f(CW$val\fR is a mixture of numbers and letters, \fIto_int()\fR will
extract the first decimal number it finds and convert that number to an integer.
.PP
.Vb 5
\&  my $int = to_int(10.5);  # Returns 10.
\&  $int = to_int(10.51);    # Returns 11.
\&  $int = to_int(\-0.22);    # Returns 0.
\&  $int = to_int(\-6.51);    # Returns 7.
\&  $int = to_int(\*(Aqfoo\*(Aq);    # Returns undef.
.Ve
.SS "is_decimal"
.IX Subsection "is_decimal"
.Vb 1
\&  my $bool = is_decimal($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a decimal number, and false if it is not. Numbers may be
preceded by a plus or minus sign. The regular expression used to test \f(CW$val\fR is
\&\f(CW\*(C`/^[+\-]?(?:\ed+(?:\e.\ed*)?|\e.\ed+)$/\*(C'\fR.
.PP
.Vb 4
\&  my $bool = is_decimal(10)    # Returns true.
\&  $bool = is_decimal(10.8)     # Returns true.
\&  $bool = is_decimal(\-33.48)   # Returns true.
\&  $bool = is_decimal((1.23e99) # Returns false.
.Ve
.SS "to_decimal"
.IX Subsection "to_decimal"
.Vb 2
\&  my $dec = to_decimal($val);
\&  $dec = to_decimal($val, $precision);
.Ve
.PP
Converts \f(CW$val\fR to a decimal number. The optional second argument sets the
precision of the number. The default precision is 5. If \f(CW$val\fR is a mixture of
numbers and letters, \fIto_decimal()\fR will extract the first decimal number it
finds.
.PP
.Vb 7
\&  my $dec = to_decimal(0);         # Returns 0.00000.
\&  $dec = to_decimal(10.5);         # Returns 10.5.
\&  $dec = to_decimal(10.500009);    # Returns 10.50001.
\&  $dec = to_decimal(10.500009, 7); # Returns 10.5000090.
\&  $dec = to_decimal(\*(Aqfoo10.3\*(Aq)     # Returns 10.30000.
\&  $dec = to_decimal(\*(Aqfoo\-4.9\*(Aq)     # Returns \-4.90000.
\&  $dec = to_decimal(\*(Aqfoo\*(Aq)         # Returns undef.
.Ve
.SS "is_real"
.IX Subsection "is_real"
.Vb 1
\&  my $bool = is_real($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a real number, and false if it is not.
.PP
\&\fBNote:\fR This function is currently equivalent to \fIis_decimal()\fR, since this
module cannot identify non-decimal real numbers (e.g., irrational numbers). This
implementation may change in the future.
.SS "to_real"
.IX Subsection "to_real"
.Vb 2
\&  my $real = to_real($val);
\&  $real = to_real($val, $precision);
.Ve
.PP
Converts \f(CW$val\fR to a real number.
.PP
\&\fBNote:\fR Currently, this function is the equivalent of \fIto_decimal()\fR, since this
module cannot identify non-decimal real numbers (e.g., irrational numbers). This
implementation may change in the future.
.SS "is_float"
.IX Subsection "is_float"
.Vb 1
\&  my $bool = is_real($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a float, and false if it is not. The regular expression
used to test \f(CW$val\fR is \f(CW\*(C`/^([+\-]?)(?=\ed|\e.\ed)\ed*(\e.\ed*)?([Ee]([+\-]?\ed+))?$/\*(C'\fR.
.PP
.Vb 3
\&  my $bool = is_real(30);   # Returns true.
\&  $bool = is_real(1.23e99); # Returns true.
\&  $bool = is_real(\*(Aqfoo\*(Aq);   # Returns false.
.Ve
.SS "to_float"
.IX Subsection "to_float"
.Vb 2
\&  my $dec = to_float($val);
\&  $dec = to_float($val, $precision);
.Ve
.PP
Converts \f(CW$val\fR to a float. The optional second argument sets the precision of the
number. The default precision is 5. If \f(CW$val\fR is a mixture of numbers and letters,
\&\fIto_float()\fR will extract the first float it finds.
.PP
.Vb 5
\&  my $float = to_float(1.23);          # Returns 1.23000.
\&  $float = to_float(1.23e99);          # Returns 1.23000e+99.
\&  $float = to_float(1.23e99, 1);       # Returns 1.2e+99.
\&  $float = to_float(\*(Aqfoo\-1.23\*(Aq);       # Returns \-1.23000.
\&  $float = to_float(\*(Aqick_1.23e99foo\*(Aq); # Returns 1.23000e+99.
.Ve
.SS "is_string"
.IX Subsection "is_string"
.Vb 1
\&  my $bool = is_string($val);
.Ve
.PP
Returns true if \f(CW$val\fR is a string, and false if it is not. All defined
non-references are considered strings.
.PP
.Vb 4
\&  my $bool = is_string(\*(Aqfoo\*(Aq); # Returns true.
\&  $bool = is_string(20001);    # Returns true.
\&  $bool = is_string([]);       # Returns false.
\&  $bool = is_string(undef);    # Returns false.
.Ve
.SS "to_string"
.IX Subsection "to_string"
.Vb 2
\&  my $string = to_string($val);
\&  $string = to_string($val, $length);
.Ve
.PP
Converts \f(CW$val\fR into a string. If \f(CW$val\fR is a reference, the string value of the
reference will be returned. Such a value may be a memory address, or some other
value, if the stringification operator has been overridden for the object stored
in \f(CW$val\fR. If the optional second argument \f(CW$length\fR is passed, \fIto_string()\fR will
truncate the string to that length. If \f(CW$length\fR is 0 (zero), it will not limit
the length of the return string. If \f(CW$val\fR is undefined, \fIto_string()\fR will return
undef.
.PP
.Vb 4
\&  my $string = to_string(\*(Aqfoo\*(Aq);   # Returns \*(Aqfoo\*(Aq.
\&  $string = to_string([]);         # Returns \*(AqARRAY(0x101bec14)\*(Aq.
\&  $string = to_string(undef);      # Returns undef.
\&  $string = to_string(\*(Aqhello\*(Aq, 4); # Returns \*(Aqhell\*(Aq.
.Ve
.SH "SUPPORT"
.IX Header "SUPPORT"
This module is stored in an open GitHub
repository <http://github.com/theory/data-types/>. Feel free to fork and
contribute!
.PP
Please file bug reports via GitHub
Issues <http://github.com/theory/data-types/issues/> or by sending mail to
bug\-Data\-Types.cpan.org <mailto:bug-Data-Types.cpan.org>.
.PP
Patches against Class::Meta are welcome. Please send bug reports to
<bug\-data\-types@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
David E. Wheeler <david@justatheory.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlfaq4
lists the most of the regular expressions used to identify the different numeric
types used in this module.
.PP
String::Checker also does some data type validation.
.PP
String::Scanf reimplements the C \f(CW\*(C`sscanf()\*(C'\fR function in
perl, and also does data type validation and conversion.
.PP
Regexp::Common contains many useful common regular expressions
(surprise!), including some that can be used to identify data types.
.PP
Arthur Bergman's types pragma, offers compile-time data types for
Perl 5.8.0. The data types include int, float, and string. I highly recommend
using this prgrma for fast, static data types.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (c) 2002\-2011, David E. Wheeler. Some Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it under the
same terms as Perl itself.
