.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "SAXT 3"
.TH SAXT 3 "2001-08-26" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Filter::SAXT \- Replicates SAX events to several SAX event handlers
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\& $saxt = new XML::Filter::SAXT ( { Handler => $out1 },
\&                                 { DocumentHandler => $out2 },
\&                                 { DTDHandler => $out3,
\&                                   Handler => $out4 
\&                                 }
\&                               );
\&
\& $perlsax = new XML::Parser::PerlSAX ( Handler => $saxt );
\& $perlsax\->parse ( [OPTIONS] );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1SAXT\s0 is like the Unix 'tee' command in that it multiplexes the input stream
to several output streams. In this case, the input stream is a PerlSAX event
producer (like XML::Parser::PerlSAX) and the output streams are PerlSAX 
handlers or filters.
.PP
The \s-1SAXT\s0 constructor takes a list of hash references. Each hash specifies
an output handler. The hash keys can be: DocumentHandler, DTDHandler, 
EntityResolver or Handler, where Handler is a combination of the previous three
and acts as the default handler.
E.g. if DocumentHandler is not specified, it will try to use Handler.
.SS "\s-1EXAMPLE\s0"
.IX Subsection "EXAMPLE"
In this example we use XML::Parser::PerlSAX to parse an \s-1XML\s0 file and
to invoke the PerlSAX callbacks of our \s-1SAXT\s0 object. The \s-1SAXT\s0 object then
forwards the callbacks to XML::Checker, which will 'die' if it encounters
an error, and to XML::Handler::BuildDOM, which will store the \s-1XML\s0 in an
XML::DOM::Document.
.PP
.Vb 4
\& use XML::Parser::PerlSAX;
\& use XML::Filter::SAXT;
\& use XML::Handler::BuildDOM;
\& use XML::Checker;
\&
\& my $checker = new XML::Checker;
\& my $builder = new XML::Handler::BuildDOM (KeepCDATA => 1);
\& my $tee = new XML::Filter::SAXT ( { Handler => $checker },
\&                                   { Handler => $builder } );
\&
\& my $parser = new XML::Parser::PerlSAX (Handler => $tee);
\& eval
\& {
\&    # This is how you set the error handler for XML::Checker
\&    local $XML::Checker::FAIL = \e&my_fail;
\&
\&    my $dom_document = $parser\->parsefile ("file.xml");
\&    ... your code here ...
\& };
\& if ($@)
\& {
\&    # Either XML::Parser::PerlSAX threw an exception (bad XML)
\&    # or XML::Checker found an error and my_fail died.
\&    ... your error handling code here ...
\& }
\&
\& # XML::Checker error handler
\& sub my_fail
\& {
\&   my $code = shift;
\&   die XML::Checker::error_string ($code, @_)
\&        if $code < 200;   # warnings and info messages are >= 200
\& }
.Ve
.SH "CAVEATS"
.IX Header "CAVEATS"
This is still alpha software. 
Package names and interfaces are subject to change.
.SH "AUTHOR"
.IX Header "AUTHOR"
Enno Dersken is the original author.
.PP
Send bug reports, hints, tips, suggestions to T.J. Mather at
<\fItjmather@tjmather.com\fR>.
