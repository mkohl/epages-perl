.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IO::Socket::Multicast6 3"
.TH IO::Socket::Multicast6 3 "2013-06-28" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
IO::Socket::Multicast6 \- Send and receive IPv4 and IPv6 multicast messages
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use IO::Socket::Multicast6;
\&
\&  # create a new IPv6 UDP socket ready to read datagrams on port 1100
\&  my $s = IO::Socket::Multicast6\->new(
\&                                Domain=>AF_INET6,
\&                                LocalPort=>1100);
\&
\&  # Add an IPv6 multicast group
\&  $s\->mcast_add(\*(AqFF15::0561\*(Aq);
\&
\&  # now receive some multicast data
\&  $s\->recv($data,1024);
\&
\&  # Drop a multicast group
\&  $s\->mcast_drop(\*(AqFF15::0561\*(Aq);
\&
\&
\&  # create a new IPv4 UDP socket ready to send datagrams to port 1100
\&  my $s = IO::Socket::Multicast6\->new(
\&                                Domain=>AF_INET,
\&                                PeerDest=>\*(Aq225.0.0.1\*(Aq,
\&                                PeerPort=>1100);
\&
\&  # Set outgoing interface to eth0
\&  $s\->mcast_if(\*(Aqeth0\*(Aq);
\&
\&  # Set time to live on outgoing multicast packets
\&  $s\->mcast_ttl(10);
\&
\&  # Turn off loopbacking
\&  $s\->mcast_loopback(0);
\&
\&  # Multicast a message to group
\&  $s\->send( \*(Aqhello world!\*(Aq );
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The IO::Socket::Multicast6 module subclasses IO::Socket::INET6 to enable
you to manipulate multicast groups.  With this module you will be able to
receive incoming multicast transmissions and generate your own
outgoing multicast packets.
.PP
This module uses the same \s-1API\s0 as IO::Socket::Multicast, but with added 
support for IPv6 (IPv4 is still supported). Unlike IO::Socket::Multicast,
this is a pure-perl module.
.SS "\s-1DEPENDENCIES\s0"
.IX Subsection "DEPENDENCIES"
This module depends on a number of other modules:
.PP
.Vb 4
\&  Socket6 version 0.19 or higher.
\&  IO::Socket::INET6 version 2.51 or higher.
\&  IO::Interface version 1.01 or higher.
\&  Socket::Multicast6 0.01 or higher.
.Ve
.PP
Your operating system must have IPv6 and Multicast support.
.SS "\s-1INTRODUCTION\s0"
.IX Subsection "INTRODUCTION"
Multicasting is designed for streaming multimedia applications and for
conferencing systems in which one transmitting machines needs to
distribute data to a large number of clients.
.PP
IPv4 addresses in the range 224.0.0.0 and 239.255.255.255 are reserved
for multicasting.  IPv6 multicast addresses start with the prefix \s-1FF\s0.
These addresses do not correspond to individual
machines, but to multicast groups.  Messages sent to these addresses
will be delivered to a potentially large number of machines that have
registered their interest in receiving transmissions on these groups.
They work like \s-1TV\s0 channels.  A program tunes in to a multicast group
to receive transmissions to it, and tunes out when it no longer
wishes to receive the transmissions.
.PP
To receive transmissions \fBfrom\fR a multicast group, you will use
IO::Socket::INET\->\fInew()\fR to create a \s-1UDP\s0 socket and bind it to a local
network port.  You will then subscribe one or more multicast groups
using the \fImcast_add()\fR method.  Subsequent calls to the standard \fIrecv()\fR
method will now receive messages incoming messages transmitted to the
subscribed groups using the selected port number.
.PP
To send transmissions \fBto\fR a multicast group, you can use the
standard \fIsend()\fR method to send messages to the multicast group and
port of your choice.
.PP
To set the number of hops (routers) that outgoing multicast messages
will cross, call \fImcast_ttl()\fR.  To activate or deactivate the looping
back of multicast messages (in which a copy of the transmitted
messages is received by the local machine), call \fImcast_loopback()\fR.
.SS "\s-1CONSTRUCTORS\s0"
.IX Subsection "CONSTRUCTORS"
.ie n .IP "$socket = IO::Socket::Multicast6\->new([LocalPort=>$port,...])" 4
.el .IP "\f(CW$socket\fR = IO::Socket::Multicast6\->new([LocalPort=>$port,...])" 4
.IX Item "$socket = IO::Socket::Multicast6->new([LocalPort=>$port,...])"
The \fInew()\fR method is the constructor for the IO::Socket::Multicast6
class.  It takes the same arguments as IO::Socket::INET, except that
the \fBProto\fR argument, rather than defaulting to \*(L"tcp\*(R", will default
to \*(L"udp\*(R", which is more appropriate for multicasting.
.Sp
To create a \s-1UDP\s0 socket suitable for sending outgoing multicast
messages, call \fInew()\fR without no arguments (or with
\&\f(CW\*(C`Proto=>\*(Aqudp\*(Aq\*(C'\fR).  To create a \s-1UDP\s0 socket that can also receive
incoming multicast transmissions on a specific port, call \fInew()\fR with
the \fBLocalPort\fR argument.
.Sp
If you plan to run the client and server on the same machine, you may
wish to set the IO::Socket \fBReuseAddr\fR argument to a true value.
This allows multiple multicast sockets to bind to the same address.
.SS "\s-1METHODS\s0"
.IX Subsection "METHODS"
.ie n .IP "$success = $socket\->mcast_add($multicast_address [,$interface])" 4
.el .IP "\f(CW$success\fR = \f(CW$socket\fR\->mcast_add($multicast_address [,$interface])" 4
.IX Item "$success = $socket->mcast_add($multicast_address [,$interface])"
The \fImcast_add()\fR method will add the provided multicast address to the
list of subscribed multicast groups.  The address may be provided
either as a dotted-quad decimal, or as a packed \s-1IP\s0 address (such as
produced by the \fIinet_aton()\fR function).  On success, the method will
return a true value.
.Sp
The optional \f(CW$interface\fR argument can be used to specify on which
network interface to listen for incoming multicast messages.  If the
IO::Interface module is installed, you may use the device name for the
interface (e.g. \*(L"tu0\*(R").  Otherwise, you must use the \s-1IP\s0 address of the
desired network interface.  Either dotted quad form or packed \s-1IP\s0
address is acceptable.  If no interface is specified, then the
multicast group is joined on \s-1INADDR_ANY\s0, meaning that multicast
transmissions received on \fBany\fR of the host's network interfaces will
be forwarded to the socket.
.Sp
Note that \fImcast_add()\fR operates on the underlying interface(s) and not
on the socket. If you have multiple sockets listening on a port, and
you \fImcast_add()\fR a group to one of those sockets, subsequently \fBall\fR
the sockets will receive mcast messages on this group. To filter
messages that can be received by a socket so that only those sent to a
particular multicast address are received, pass the \fBLocalAddr\fR
option to the socket at the time you create it:
.Sp
.Vb 4
\&  my $socket = IO::Socket::Multicast6\->new(LocalPort=>2000,
\&                                          LocalAddr=>226.1.1.2\*(Aq,
\&                                          ReuseAddr=>1);
\&  $socket\->mcast_add(\*(Aq226.1.1.2\*(Aq);
.Ve
.Sp
By combining this technique with IO::Select, you can write
applications that listen to multiple multicast groups and distinguish
which group a message was addressed to by identifying which socket it
was received on.
.ie n .IP "$success = $socket\->mcast_add_source($multicast_add, $source_addr [,$interface])" 4
.el .IP "\f(CW$success\fR = \f(CW$socket\fR\->mcast_add_source($multicast_add, \f(CW$source_addr\fR [,$interface])" 4
.IX Item "$success = $socket->mcast_add_source($multicast_add, $source_addr [,$interface])"
Same as \fImcast_add()\fR but for Source Specific Multicast (\s-1SSM\s0).
.ie n .IP "$success = $socket\->mcast_drop($multicast_address)" 4
.el .IP "\f(CW$success\fR = \f(CW$socket\fR\->mcast_drop($multicast_address)" 4
.IX Item "$success = $socket->mcast_drop($multicast_address)"
This reverses the action of \fImcast_add()\fR, removing the indicated
multicast address from the list of subscribed groups.
.ie n .IP "$loopback = $socket\->mcast_loopback" 4
.el .IP "\f(CW$loopback\fR = \f(CW$socket\fR\->mcast_loopback" 4
.IX Item "$loopback = $socket->mcast_loopback"
.PD 0
.ie n .IP "$previous = $socket\->mcast_loopback($new)" 4
.el .IP "\f(CW$previous\fR = \f(CW$socket\fR\->mcast_loopback($new)" 4
.IX Item "$previous = $socket->mcast_loopback($new)"
.PD
The \fImcast_loopback()\fR method controls whether the socket will receive
its own multicast transmissions (default yes).  Called without
arguments, the method returns the current state of the loopback
flag. Called with a boolean argument, the method will set the loopback
flag, and return its previous value.
.ie n .IP "$ttl = $socket\->mcast_ttl" 4
.el .IP "\f(CW$ttl\fR = \f(CW$socket\fR\->mcast_ttl" 4
.IX Item "$ttl = $socket->mcast_ttl"
.PD 0
.ie n .IP "$previous = $socket\->mcast_ttl($new)" 4
.el .IP "\f(CW$previous\fR = \f(CW$socket\fR\->mcast_ttl($new)" 4
.IX Item "$previous = $socket->mcast_ttl($new)"
.PD
The \fImcast_ttl()\fR method examines or sets the time to live (\s-1TTL\s0) for
outgoing multicast messages.  The \s-1TTL\s0 controls the numbers of routers
the packet can cross before being expired.  The default \s-1TTL\s0 is 1,
meaning that the message is confined to the local area network.
Values between 0 and 255 are valid.
.Sp
Called without arguments, this method returns the socket's current
\&\s-1TTL\s0.  Called with a value, this method sets the \s-1TTL\s0 and returns its
previous value.
.ie n .IP "$interface = $socket\->mcast_if" 4
.el .IP "\f(CW$interface\fR = \f(CW$socket\fR\->mcast_if" 4
.IX Item "$interface = $socket->mcast_if"
.PD 0
.ie n .IP "$previous = $socket\->mcast_if($new)" 4
.el .IP "\f(CW$previous\fR = \f(CW$socket\fR\->mcast_if($new)" 4
.IX Item "$previous = $socket->mcast_if($new)"
.PD
By default, the \s-1OS\s0 will pick the network interface to use for outgoing
multicasts automatically.  You can control this process by using the
\&\fImcast_if()\fR method to set the outgoing network interface explicitly.
Called without arguments, returns the current interface.  Called with
the name of an interface, sets the outgoing interface and returns its
previous value.
.Sp
You can use the device name for the interface (e.g. \*(L"tu0\*(R") if the
IO::Interface module is present.  Otherwise, you must use the
interface's dotted \s-1IP\s0 address.
.Sp
\&\fB\s-1NOTE\s0\fR: To set the interface used for \fBincoming\fR multicasts, use the
\&\fImcast_add()\fR method.
.ie n .IP "$dest = $socket\->mcast_dest" 4
.el .IP "\f(CW$dest\fR = \f(CW$socket\fR\->mcast_dest" 4
.IX Item "$dest = $socket->mcast_dest"
.PD 0
.ie n .IP "$previous = $socket\->mcast_dest($address [, $port])" 4
.el .IP "\f(CW$previous\fR = \f(CW$socket\fR\->mcast_dest($address [, \f(CW$port\fR])" 4
.IX Item "$previous = $socket->mcast_dest($address [, $port])"
.PD
The \fImcast_dest()\fR method is a convenience function that allows you to
set the default destination group for outgoing multicasts.  Called
without arguments, returns the current destination as a packed binary
sockaddr_in/sockaddr_in6 data structure.  Called with a new destination 
address, the method sets the default destination and returns the previous 
one, if any.
.Sp
Destination addresses may be provided as packed sockaddr_in/sockaddr_in6
structures, or address and port as strings.
.Sp
For IPv4 the address can be supplied in the form \*(L"\s-1XX\s0.XX.XX.XX:YY\*(R" where 
the first part is the IPv4 address, and the second the port number.
.Sp
For IPv6 the address can be supplied in the form 
\&\*(L"[\s-1FFXX:XXXX::XXXX\s0]:YY\*(R" where the first part is the IPv6 address,
and the second the port number.
.Sp
Alternatively the port can be supplied as an additional parameter, 
separate to the address.
.ie n .IP "$bytes = $socket\->mcast_send($data [,$address [,$port]])" 4
.el .IP "\f(CW$bytes\fR = \f(CW$socket\fR\->mcast_send($data [,$address [,$port]])" 4
.IX Item "$bytes = $socket->mcast_send($data [,$address [,$port]])"
\&\fImcast_send()\fR is a convenience function that simplifies the sending of
multicast messages.  \f(CW$data\fR is the message contents, and \f(CW$dest\fR is
an optional destination group.  You can use either the dotted \s-1IP\s0 form
of the destination address and its port number, or a packed
sockaddr_in/sockaddr_in6 structure.  If the destination is not supplied, 
it will default to the most recent value set in \fImcast_dest()\fR or a previous
call to \fImcast_send()\fR.
.Sp
The method returns the number of bytes successfully queued for
delivery.
.Sp
As a side-effect, the method will call \fImcast_dest()\fR to remember the
destination address.
.Sp
Example:
.Sp
.Vb 2
\&  $socket\->mcast_send(\*(AqHi there group members!\*(Aq,\*(Aq225.0.1.1:1900\*(Aq) || die;
\&  $socket\->mcast_send("How\*(Aqs the weather?") || die;
.Ve
.Sp
Note that you may still call IO::Socket::INET6\->\fInew()\fR with a
\&\fBPeerAddr\fR, and IO::Socket::INET6 will perform a \fIconnect()\fR, creating a
default destination for calls to \fIsend()\fR.
.SH "EXAMPLE"
.IX Header "EXAMPLE"
The following is an example of a multicast server.  Every 10 seconds
it transmits the current time and the list of logged-in users to the
local network using multicast group \s-1FF15::0561\s0, port 2000 (these are
chosen arbitrarily, the \s-1FF15::\s0 is a Transient, Site Local prefix).
.PP
.Vb 4
\& #!/usr/bin/perl
\& # server (transmitter)
\& use strict;
\& use IO::Socket::Multicast6;
\&
\& use constant GROUP => \*(AqFF15::0561\*(Aq;
\& use constant PORT  => \*(Aq2000\*(Aq;
\& 
\& my $sock = IO::Socket::Multicast6\->new(
\&                    Proto=>\*(Aqudp\*(Aq,
\&                    Domain=>AF_INET6,
\&                    PeerAddr=>GROUP,
\&                    PeerPort=>PORT);
\&
\& while (1) {
\&    my $message = localtime();
\&    $sock\->send($message) || die "Couldn\*(Aqt send: $!";
\& } continue {
\&    sleep 4;
\& }
.Ve
.PP
This is the corresponding client.  It listens for transmissions on
group \s-1FF15::0561\s0, port 2000, and echoes the messages to standard
output.
.PP
.Vb 2
\& #!/usr/bin/perl
\& # client (receiver)
\&
\& use strict;
\& use IO::Socket::Multicast6;
\&
\& use constant GROUP => \*(AqFF15::0561\*(Aq;
\& use constant PORT  => \*(Aq2000\*(Aq;
\&
\& my $sock = IO::Socket::Multicast6\->new(
\&                    Proto=>\*(Aqudp\*(Aq,
\&                    Domain=>AF_INET6,
\&                    LocalAddr=>GROUP,
\&                    LocalPort=>PORT);
\&                    
\& $sock\->mcast_add(GROUP) || die "Couldn\*(Aqt set group: $!\en";
\&
\& while (1) {
\&    my $data;
\&    next unless $sock\->recv($data,1024);
\&    print "$data\en";
\& }
.Ve
.SS "\s-1BUGS\s0"
.IX Subsection "BUGS"
The \fImcast_if()\fR, \fImcast_ttl()\fR and \fImcast_loopback()\fR methods will cause a
crash on versions of Linux earlier than 2.2.0 because of a kernel bug
in the implementation of the multicast socket options.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
<http://www.ietf.org/rfc/rfc2553.txt>
.PP
\&\fIperl\fR\|(1), \fIIO::Socket\fR\|(3), \fISocket::Multicast6\fR\|(3), \fIIO::Socket::INET6\fR\|(3).
.SH "AUTHOR"
.IX Header "AUTHOR"
Based on IO::Socket::Multicast by Lincoln Stein, lstein@cshl.org.
.PP
IO::Socket::Multicast6 by Nicholas J Humfrey, <njh@cpan.org>.
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
Copyright (C) 2006\-2009 Nicholas J Humfrey
Copyright (C) 2000\-2005 Lincoln Stein
.PP
This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself, either Perl version 5.6.1 or,
at your option, any later version of Perl 5 you may have available.
