.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MongoDB::Collection 3"
.TH MongoDB::Collection 3 "2013-08-27" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MongoDB::Collection \- A MongoDB Collection
.SH "VERSION"
.IX Header "VERSION"
version 0.702.2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
An instance of a MongoDB collection.
.PP
.Vb 2
\&    # gets the foo collection
\&    my $collection = $db\->get_collection( \*(Aqfoo\*(Aq );
.Ve
.PP
Collection names can be chained together to access subcollections.  For
instance, the collection \f(CW\*(C`foo.bar\*(C'\fR can be accessed with either:
.PP
.Vb 1
\&    my $collection = $db\->get_collection( \*(Aqfoo\*(Aq )\->get_collection( \*(Aqbar\*(Aq );
.Ve
.PP
or
.PP
.Vb 1
\&    my $collection = $db\->get_collection( \*(Aqfoo.bar\*(Aq );
.Ve
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "name"
.IX Subsection "name"
The name of the collection.
.SS "full_name"
.IX Subsection "full_name"
The full_name of the collection, including the namespace of the database it's
in.
.SH "METHODS"
.IX Header "METHODS"
.SS "get_collection ($name)"
.IX Subsection "get_collection ($name)"
.Vb 1
\&    my $collection = $database\->get_collection(\*(Aqfoo\*(Aq);
.Ve
.PP
Returns a MongoDB::Collection for the collection called \f(CW$name\fR within this
collection.
.SS "find($query)"
.IX Subsection "find($query)"
.Vb 1
\&    my $cursor = $collection\->find({ i => { \*(Aq$gt\*(Aq => 42 } });
.Ve
.PP
Executes the given \f(CW$query\fR and returns a \f(CW\*(C`MongoDB::Cursor\*(C'\fR with the results.
\&\f(CW$query\fR can be a hash reference, Tie::IxHash, or array reference (with an
even number of elements).
.PP
The set of fields returned can be limited through the use of the
\&\f(CW\*(C`MongoDB::Cursor::fields\*(C'\fR method on the resulting MongoDB::Cursor object.
Other commonly used cursor methods are \f(CW\*(C`MongoDB::Cursor::limit\*(C'\fR,
\&\f(CW\*(C`MongoDB::Cursor::skip\*(C'\fR, and \f(CW\*(C`MongoDB::Cursor::sort\*(C'\fR.
.PP
See also core documentation on querying:
<http://docs.mongodb.org/manual/core/read/>.
.ie n .SS "query($query, $attrs?)"
.el .SS "query($query, \f(CW$attrs\fP?)"
.IX Subsection "query($query, $attrs?)"
Identical to \f(CW\*(C`MongoDB::Collection::find\*(C'\fR, described above.
.PP
.Vb 1
\&    my $cursor = $collection\->query\->limit(10)\->skip(10);
\&
\&    my $cursor = $collection\->query({ location => "Vancouver" })\->sort({ age => 1 });
.Ve
.PP
Valid query attributes are:
.IP "limit" 4
.IX Item "limit"
Limit the number of results.
.IP "skip" 4
.IX Item "skip"
Skip a number of results.
.IP "sort_by" 4
.IX Item "sort_by"
Order results.
.ie n .SS "find_one($query, $fields?)"
.el .SS "find_one($query, \f(CW$fields\fP?)"
.IX Subsection "find_one($query, $fields?)"
.Vb 2
\&    my $object = $collection\->find_one({ name => \*(AqResi\*(Aq });
\&    my $object = $collection\->find_one({ name => \*(AqResi\*(Aq }, { name => 1, age => 1});
.Ve
.PP
Executes the given \f(CW$query\fR and returns the first object matching it.
\&\f(CW$query\fR can be a hash reference, Tie::IxHash, or array reference (with an
even number of elements).  If \f(CW$fields\fR is specified, the resulting document
will only include the fields given (and the \f(CW\*(C`_id\*(C'\fR field) which can cut down on
wire traffic.
.ie n .SS "insert ($object, $options?)"
.el .SS "insert ($object, \f(CW$options\fP?)"
.IX Subsection "insert ($object, $options?)"
.Vb 2
\&    my $id1 = $coll\->insert({ name => \*(Aqmongo\*(Aq, type => \*(Aqdatabase\*(Aq });
\&    my $id2 = $coll\->insert({ name => \*(Aqmongo\*(Aq, type => \*(Aqdatabase\*(Aq }, {safe => 1});
.Ve
.PP
Inserts the given \f(CW$object\fR into the database and returns it's id
value. \f(CW$object\fR can be a hash reference, a reference to an array with an
even number of elements, or a Tie::IxHash.  The id is the \f(CW\*(C`_id\*(C'\fR value
specified in the data or a MongoDB::OID.
.PP
The optional \f(CW$options\fR parameter can be used to specify if this is a safe
insert.  A safe insert will check with the database if the insert succeeded and
croak if it did not.  You can also check if the insert succeeded by doing an
unsafe insert, then calling \*(L"last_error($options?)\*(R" in MongoDB::Database.
.PP
See also core documentation on insert: <http://docs.mongodb.org/manual/core/create/>.
.ie n .SS "batch_insert (\e@array, $options)"
.el .SS "batch_insert (\e@array, \f(CW$options\fP)"
.IX Subsection "batch_insert (@array, $options)"
.Vb 1
\&    my @ids = $collection\->batch_insert([{name => "Joe"}, {name => "Fred"}, {name => "Sam"}]);
.Ve
.PP
Inserts each of the documents in the array into the database and returns an
array of their _id fields.
.PP
The optional \f(CW$options\fR parameter can be used to specify if this is a safe
insert.  A safe insert will check with the database if the insert succeeded and
croak if it did not. You can also check if the inserts succeeded by doing an
unsafe batch insert, then calling \*(L"last_error($options?)\*(R" in MongoDB::Database.
.SS "update (\e%criteria, \e%object, \e%options?)"
.IX Subsection "update (%criteria, %object, %options?)"
.Vb 1
\&    $collection\->update({\*(Aqx\*(Aq => 3}, {\*(Aq$inc\*(Aq => {\*(Aqcount\*(Aq => \-1} }, {"upsert" => 1, "multiple" => 1});
.Ve
.PP
Updates an existing \f(CW$object\fR matching \f(CW$criteria\fR in the database.
.PP
Returns 1 unless the \f(CW\*(C`safe\*(C'\fR option is set. If \f(CW\*(C`safe\*(C'\fR is set, this will return
a hash of information about the update, including number of documents updated
(\f(CW\*(C`n\*(C'\fR).  If \f(CW\*(C`safe\*(C'\fR is set and the update fails, \f(CW\*(C`update\*(C'\fR will croak. You can
also check if the update succeeded by doing an unsafe update, then calling
\&\*(L"last_error($options?)\*(R" in MongoDB::Database.
.PP
\&\f(CW\*(C`update\*(C'\fR can take a hash reference of options.  The options currently supported
are:
.ie n .IP """upsert"" If no object matching $criteria is found, $object will be inserted." 4
.el .IP "\f(CWupsert\fR If no object matching \f(CW$criteria\fR is found, \f(CW$object\fR will be inserted." 4
.IX Item "upsert If no object matching $criteria is found, $object will be inserted."
.PD 0
.ie n .IP """multiple"" All of the documents that match $criteria will be updated, not just the first document found. (Only available with database version 1.1.3 and newer.)" 4
.el .IP "\f(CWmultiple\fR All of the documents that match \f(CW$criteria\fR will be updated, not just the first document found. (Only available with database version 1.1.3 and newer.)" 4
.IX Item "multiple All of the documents that match $criteria will be updated, not just the first document found. (Only available with database version 1.1.3 and newer.)"
.ie n .IP """safe"" If the update fails and safe is set, the update will croak." 4
.el .IP "\f(CWsafe\fR If the update fails and safe is set, the update will croak." 4
.IX Item "safe If the update fails and safe is set, the update will croak."
.PD
.PP
See also core documentation on update: <http://docs.mongodb.org/manual/core/update/>.
.SS "find_and_modify"
.IX Subsection "find_and_modify"
.Vb 1
\&    my $result = $collection\->find_and_modify( { query => { ... }, update => { ... } } );
.Ve
.PP
Perform an atomic update. \f(CW\*(C`find_and_modify\*(C'\fR guarantees that nothing else will come along
and change the queried documents before the update is performed.
.PP
Returns the old version of the document, unless \f(CW\*(C`new =\*(C'\fR 1> is specified. If no documents
match the query, it returns nothing.
.SS "aggregate"
.IX Subsection "aggregate"
.Vb 1
\&    my $result = $collection\->aggregate( [ ... ] );
.Ve
.PP
Run a query using the MongoDB 2.2+ aggregation framework. The argument is an array-ref of 
aggregation pipeline operators. Returns an array-ref containing the results of 
the query. See Aggregation <http://docs.mongodb.org/manual/aggregation/> in the MongoDB manual
for more information on how to construct aggregation queries.
.ie n .SS "rename (""newcollectionname"")"
.el .SS "rename (``newcollectionname'')"
.IX Subsection "rename (newcollectionname)"
.Vb 1
\&    my $newcollection = $collection\->rename("mynewcollection");
.Ve
.PP
Renames the collection.  It expects that the new name is currently not in use.
.PP
Returns the new collection.  If a collection already exists with that new collection name this will
die.
.ie n .SS "save($doc, $options)"
.el .SS "save($doc, \f(CW$options\fP)"
.IX Subsection "save($doc, $options)"
.Vb 2
\&    $collection\->save({"author" => "joe"});
\&    my $post = $collection\->find_one;
\&
\&    $post\->{author} = {"name" => "joe", "id" => 123, "phone" => "555\-5555"};
\&
\&    $collection\->save( $post );
\&    $collection\->save( $post, { safe => 1 } )
.Ve
.PP
Inserts a document into the database if it does not have an _id field, upserts
it if it does have an _id field.
.PP
The return types for this function are a bit of a mess, as it will return the
_id if a new document was inserted, 1 if an upsert occurred, and croak if the
safe option was set and an error occurred.  You can also check if the save
succeeded by doing an unsafe save, then calling
\&\*(L"last_error($options?)\*(R" in MongoDB::Database.
.ie n .SS "remove ($query?, $options?)"
.el .SS "remove ($query?, \f(CW$options\fP?)"
.IX Subsection "remove ($query?, $options?)"
.Vb 1
\&    $collection\->remove({ answer => { \*(Aq$ne\*(Aq => 42 } });
.Ve
.PP
Removes all objects matching the given \f(CW$query\fR from the database. If no
parameters are given, removes all objects from the collection (but does not
delete indexes, as \f(CW\*(C`MongoDB::Collection::drop\*(C'\fR does).
.PP
Returns 1 unless the \f(CW\*(C`safe\*(C'\fR option is set.  If \f(CW\*(C`safe\*(C'\fR is set and the remove
succeeds, \f(CW\*(C`remove\*(C'\fR will return a hash of information about the remove,
including how many documents were removed (\f(CW\*(C`n\*(C'\fR).  If the remove fails and
\&\f(CW\*(C`safe\*(C'\fR is set, \f(CW\*(C`remove\*(C'\fR will croak.  You can also check if the remove
succeeded by doing an unsafe remove, then calling
\&\*(L"last_error($options?)\*(R" in MongoDB::Database.
.PP
\&\f(CW\*(C`remove\*(C'\fR can take a hash reference of options.  The options currently supported
are
.ie n .IP """just_one"" Only one matching document to be removed." 4
.el .IP "\f(CWjust_one\fR Only one matching document to be removed." 4
.IX Item "just_one Only one matching document to be removed."
.PD 0
.ie n .IP """safe"" If the update fails and safe is set, this function will croak." 4
.el .IP "\f(CWsafe\fR If the update fails and safe is set, this function will croak." 4
.IX Item "safe If the update fails and safe is set, this function will croak."
.PD
.PP
See also core documentation on remove: <http://docs.mongodb.org/manual/core/delete/>.
.ie n .SS "ensure_index ($keys, $options?)"
.el .SS "ensure_index ($keys, \f(CW$options\fP?)"
.IX Subsection "ensure_index ($keys, $options?)"
.Vb 2
\&    use boolean;
\&    $collection\->ensure_index({"foo" => 1, "bar" => \-1}, { unique => true });
.Ve
.PP
Makes sure the given \f(CW$keys\fR of this collection are indexed. \f(CW$keys\fR can be an
array reference, hash reference, or \f(CW\*(C`Tie::IxHash\*(C'\fR.  \f(CW\*(C`Tie::IxHash\*(C'\fR is preferred
for multi-key indexes, so that the keys are in the correct order.  1 creates an
ascending index, \-1 creates a descending index.
.PP
If the \f(CW\*(C`safe\*(C'\fR option is not set, \f(CW\*(C`ensure_index\*(C'\fR will not return anything
unless there is a socket error (in which case it will croak).  If the \f(CW\*(C`safe\*(C'\fR
option is set and the index creation fails, it will also croak. You can also
check if the indexing succeeded by doing an unsafe index creation, then calling
\&\*(L"last_error($options?)\*(R" in MongoDB::Database.
.PP
See the MongoDB::Indexing pod for more information on indexing.
.SS "count($query?)"
.IX Subsection "count($query?)"
.Vb 1
\&    my $n_objects = $collection\->count({ name => \*(AqBob\*(Aq });
.Ve
.PP
Counts the number of objects in this collection that match the given \f(CW$query\fR.
If no query is given, the total number of objects in the collection is returned.
.SS "validate"
.IX Subsection "validate"
.Vb 1
\&    $collection\->validate;
.Ve
.PP
Asks the server to validate this collection.
Returns a hash of the form:
.PP
.Vb 5
\&    {
\&        \*(Aqok\*(Aq => \*(Aq1\*(Aq,
\&        \*(Aqns\*(Aq => \*(Aqfoo.bar\*(Aq,
\&        \*(Aqresult\*(Aq => info
\&    }
.Ve
.PP
where \f(CW\*(C`info\*(C'\fR is a string of information
about the collection.
.SS "drop_indexes"
.IX Subsection "drop_indexes"
.Vb 1
\&    $collection\->drop_indexes;
.Ve
.PP
Removes all indexes from this collection.
.SS "drop_index ($index_name)"
.IX Subsection "drop_index ($index_name)"
.Vb 1
\&    $collection\->drop_index(\*(Aqfoo_1\*(Aq);
.Ve
.PP
Removes an index called \f(CW$index_name\fR from this collection.
Use \f(CW\*(C`MongoDB::Collection::get_indexes\*(C'\fR to find the index name.
.SS "get_indexes"
.IX Subsection "get_indexes"
.Vb 1
\&    my @indexes = $collection\->get_indexes;
.Ve
.PP
Returns a list of all indexes of this collection.
Each index contains \f(CW\*(C`ns\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`key\*(C'\fR
fields of the form:
.PP
.Vb 10
\&    {
\&        \*(Aqns\*(Aq => \*(Aqdb_name.collection_name\*(Aq,
\&        \*(Aqname\*(Aq => \*(Aqindex_name\*(Aq,
\&        \*(Aqkey\*(Aq => {
\&            \*(Aqkey1\*(Aq => dir1,
\&            \*(Aqkey2\*(Aq => dir2,
\&            ...
\&            \*(AqkeyN\*(Aq => dirN
\&        }
\&    }
.Ve
.PP
where \f(CW\*(C`dirX\*(C'\fR is 1 or \-1, depending on if the
index is ascending or descending on that key.
.SS "drop"
.IX Subsection "drop"
.Vb 1
\&    $collection\->drop;
.Ve
.PP
Deletes a collection as well as all of its indexes.
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Kristina Chodorow <kristina@mongodb.org>
.IP "\(bu" 4
Mike Friedman <friedo@mongodb.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by MongoDB, Inc..
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
