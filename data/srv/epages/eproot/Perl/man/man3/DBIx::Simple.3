.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "DBIx::Simple 3"
.TH DBIx::Simple 3 "2011-01-04" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
DBIx::Simple \- Very complete easy\-to\-use OO interface to DBI
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "DBIx::Simple"
.IX Subsection "DBIx::Simple"
.Vb 1
\&    $db = DBIx::Simple\->connect(...)  # or \->new
\&
\&    $db\->keep_statements = 16
\&    $db\->lc_columns = 1
\&    $db\->result_class = \*(AqDBIx::Simple::Result\*(Aq;
\&
\&    $db\->begin_work         $db\->commit
\&    $db\->rollback           $db\->disconnect
\&    $db\->func(...)          $db\->last_insert_id
\&
\&    $result = $db\->query(...)
.Ve
.SS "DBIx::SImple + SQL::Interp"
.IX Subsection "DBIx::SImple + SQL::Interp"
.Vb 1
\&    $result = $db\->iquery(...)
.Ve
.SS "DBIx::Simple + SQL::Abstract"
.IX Subsection "DBIx::Simple + SQL::Abstract"
.Vb 1
\&    $db\->abstract = SQL::Abstract\->new(...)
\&
\&    $result = $db\->select(...)
\&    $result = $db\->insert(...)
\&    $result = $db\->update(...)
\&    $result = $db\->delete(...)
.Ve
.SS "DBIx::Simple::Result"
.IX Subsection "DBIx::Simple::Result"
.Vb 1
\&    @columns = $result\->columns
\&
\&    $result\->into($foo, $bar, $baz)
\&    $row = $result\->fetch
\&
\&    @row = $result\->list      @rows = $result\->flat
\&    $row = $result\->array     @rows = $result\->arrays
\&    $row = $result\->hash      @rows = $result\->hashes
\&    @row = $result\->kv_list   @rows = $result\->kv_flat
\&    $row = $result\->kv_array  @rows = $result\->kv_arrays
\&    $obj = $result\->object    @objs = $result\->objects
\&
\&    %map = $result\->map_arrays(...)
\&    %map = $result\->map_hashes(...)
\&    %map = $result\->map
\&
\&    $rows = $result\->rows
\&
\&    $dump = $result\->text
\&
\&    $result\->finish
.Ve
.SS "DBIx::Simple::Result + DBIx::XHTML_Table"
.IX Subsection "DBIx::Simple::Result + DBIx::XHTML_Table"
.Vb 1
\&    $html = $result\->html(...)
\&
\&    $table_object = $result\->xto(...)
.Ve
.SS "Examples"
.IX Subsection "Examples"
Please read DBIx::Simple::Examples for code examples.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DBIx::Simple provides a simplified interface to \s-1DBI\s0, Perl's powerful database
module.
.PP
This module is aimed at rapid development and easy maintenance. Query
preparation and execution are combined in a single method, the result object
(which is a wrapper around the statement handle) provides easy row-by-row and
slurping methods.
.PP
The \f(CW\*(C`query\*(C'\fR method returns either a result object, or a dummy object. The
dummy object returns undef (or an empty list) for all methods and when used in
boolean context, is false. The dummy object lets you postpone (or skip) error
checking, but it also makes immediate error checking simply \f(CW\*(C`$db\->query(...) or die $db\->error\*(C'\fR.
.SS "DBIx::Simple methods"
.IX Subsection "DBIx::Simple methods"
\fIClass methods\fR
.IX Subsection "Class methods"
.ie n .IP """connect($dbh)"", ""connect($dsn, $user, $pass, \e%options)""" 14
.el .IP "\f(CWconnect($dbh)\fR, \f(CWconnect($dsn, $user, $pass, \e%options)\fR" 14
.IX Item "connect($dbh), connect($dsn, $user, $pass, %options)"
.PD 0
.ie n .IP """new($dbh)"", ""new($dsn, $user, $pass, \e%options)""" 14
.el .IP "\f(CWnew($dbh)\fR, \f(CWnew($dsn, $user, $pass, \e%options)\fR" 14
.IX Item "new($dbh), new($dsn, $user, $pass, %options)"
.PD
The \f(CW\*(C`connect\*(C'\fR or \f(CW\*(C`new\*(C'\fR class method takes either an existing \s-1DBI\s0 object
($dbh), or a list of arguments to pass to \f(CW\*(C`DBI\->connect\*(C'\fR. See \s-1DBI\s0 for a
detailed description.
.Sp
You cannot use this method to clone a DBIx::Simple object: the \f(CW$dbh\fR passed
should be a DBI::db object, not a DBIx::Simple object.
.Sp
For new connections, PrintError is disabled by default. If you enable it,
beware that it will report line numbers in DBIx/Simple.pm.
.Sp
For new connections, \fBRaiseError is enabled by default\fR unless the environment
variable \f(CW\*(C`PERL_DBIX_SIMPLE_NO_RAISEERROR\*(C'\fR is set to a non-empty non\-0 value.
.Sp
This method is the constructor and returns a DBIx::Simple object on success. On
failure, it returns undef.
.PP
\fIObject methods\fR
.IX Subsection "Object methods"
.ie n .IP """query($query, @values)""" 14
.el .IP "\f(CWquery($query, @values)\fR" 14
.IX Item "query($query, @values)"
Prepares and executes the query and returns a result object.
.Sp
If the string \f(CW\*(C`(??)\*(C'\fR is present in the query, it is replaced with a list of as
many question marks as \f(CW@values\fR.
.Sp
The database drivers substitute placeholders (question marks that do not appear
in quoted literals) in the query with the given \f(CW@values\fR, after them escaping
them. You should always use placeholders, and never use raw user input in
database queries.
.Sp
On success, returns a DBIx::Simple::Result object. On failure, returns a
DBIx::Simple::Dummy object.
.ie n .IP """iquery(...)""" 14
.el .IP "\f(CWiquery(...)\fR" 14
.IX Item "iquery(...)"
Uses SQL::Interp to interpolate values into a query, and uses the resulting
generated query and bind arguments with \f(CW\*(C`query\*(C'\fR. See SQL::Interp's
documentation for usage information.
.Sp
Requires Mark Storberg's SQL::Interp, which is available from \s-1CPAN\s0. SQL::Interp
is a fork from David Manura's SQL::Interpolate.
.ie n .IP """select"", ""insert"", ""update"", ""delete""" 14
.el .IP "\f(CWselect\fR, \f(CWinsert\fR, \f(CWupdate\fR, \f(CWdelete\fR" 14
.IX Item "select, insert, update, delete"
Calls the respective method on \f(CW\*(C`abstract\*(C'\fR, and uses the resulting generated
query and bind arguments with \f(CW\*(C`query\*(C'\fR. See SQL::Abstract's documentation for
usage information. You can override the object by assigning to the \f(CW\*(C`abstract\*(C'\fR
property.
.Sp
Requires Nathan Wiger's SQL::Abstract, which is available from \s-1CPAN\s0.
.ie n .IP """begin_work"", ""begin"", ""commit"", ""rollback""" 14
.el .IP "\f(CWbegin_work\fR, \f(CWbegin\fR, \f(CWcommit\fR, \f(CWrollback\fR" 14
.IX Item "begin_work, begin, commit, rollback"
These transaction related methods call the \s-1DBI\s0 respective methods and
Do What You Mean. See \s-1DBI\s0 for details.
.Sp
\&\f(CW\*(C`begin\*(C'\fR is an alias for \f(CW\*(C`begin_work\*(C'\fR.
.ie n .IP """func(...)""" 14
.el .IP "\f(CWfunc(...)\fR" 14
.IX Item "func(...)"
Calls the \f(CW\*(C`func\*(C'\fR method of \s-1DBI\s0. See \s-1DBI\s0 for details.
.ie n .IP """last_insert_id(...)""" 14
.el .IP "\f(CWlast_insert_id(...)\fR" 14
.IX Item "last_insert_id(...)"
Calls the \f(CW\*(C`last_insert_id\*(C'\fR method of \s-1DBI\s0. See \s-1DBI\s0 for details. Note that
this feature requires \s-1DBI\s0 1.38 or newer.
.ie n .IP """disconnect""" 14
.el .IP "\f(CWdisconnect\fR" 14
.IX Item "disconnect"
Destroys (finishes) active statements and disconnects. Whenever the database
object is destroyed, this happens automatically if DBIx::Simple handled the
connection (i.e. you didn't use an existing \s-1DBI\s0 handle). After disconnecting,
you can no longer use the database object or any of its result objects.
.PP
\fIObject properties\fR
.IX Subsection "Object properties"
.ie n .IP """dbh""" 14
.el .IP "\f(CWdbh\fR" 14
.IX Item "dbh"
Exposes the internal database handle. Use this only if you know what you are
doing. Keeping a reference or doing queries can interfere with DBIx::Simple's
garbage collection and error reporting.
.ie n .IP """lc_columns = $bool""" 14
.el .IP "\f(CWlc_columns = $bool\fR" 14
.IX Item "lc_columns = $bool"
When true at time of query execution, makes several result object methods use
lower cased column names. \f(CW\*(C`lc_columns\*(C'\fR is true by default.
.ie n .IP """keep_statements = $integer""" 14
.el .IP "\f(CWkeep_statements = $integer\fR" 14
.IX Item "keep_statements = $integer"
Sets the number of statement objects that DBIx::Simple can keep for reuse. This
can dramatically speed up repeated queries (like when used in a loop).
\&\f(CW\*(C`keep_statements\*(C'\fR is 16 by default.
.Sp
A query is only reused if it equals a previously used one literally. This means
that to benefit from this caching mechanism, you must use placeholders and
never interpolate variables yourself.
.Sp
.Vb 3
\&    # Wrong:
\&    $db\->query("INSERT INTO foo VALUES (\*(Aq$foo\*(Aq, \*(Aq$bar\*(Aq, \*(Aq$baz\*(Aq)");
\&    $db\->query("SELECT FROM foo WHERE foo = \*(Aq$foo\*(Aq OR bar = \*(Aq$bar\*(Aq");
\&
\&    # Right:
\&    $db\->query(\*(AqINSERT INTO foo VALUES (??)\*(Aq, $foo, $bar, $baz);
\&    $db\->query(\*(AqSELECT FROM foo WHERE foo = ? OR bar = ?\*(Aq, $foo, $baz);
.Ve
.Sp
Of course, automatic value escaping is a much better reason for using
placeholders.
.ie n .IP """result_class = $string""" 14
.el .IP "\f(CWresult_class = $string\fR" 14
.IX Item "result_class = $string"
Class to use for result objects. Defaults to DBIx::Simple::Result. A
constructor is not used.
.ie n .IP """error""" 14
.el .IP "\f(CWerror\fR" 14
.IX Item "error"
Returns the error string of the last \s-1DBI\s0 method. See the discussion of "\f(CW\*(C`err\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`errstr\*(C'\fR" in \s-1DBI\s0.
.ie n .IP """abstract = SQL::Abstract\->new(...)""" 14
.el .IP "\f(CWabstract = SQL::Abstract\->new(...)\fR" 14
.IX Item "abstract = SQL::Abstract->new(...)"
Sets the object to use with the \f(CW\*(C`select\*(C'\fR, \f(CW\*(C`insert\*(C'\fR, \f(CW\*(C`update\*(C'\fR and \f(CW\*(C`delete\*(C'\fR
methods. On first access, will create one with SQL::Abstract's default options.
.Sp
Requires Nathan Wiger's SQL::Abstract, which is available from \s-1CPAN\s0.
.Sp
In theory, you can assign any object to this property, as long as that object
has these four methods, and they return a list suitable for use with the
\&\f(CW\*(C`query\*(C'\fR method.
.SS "DBIx::Simple::Dummy"
.IX Subsection "DBIx::Simple::Dummy"
The \f(CW\*(C`query\*(C'\fR method of DBIx::Simple returns a dummy object on failure. Its
methods all return an empty list or undef, depending on context. When used in
boolean context, a dummy object evaluates to false.
.SS "DBIx::Simple::Result methods"
.IX Subsection "DBIx::Simple::Result methods"
Methods documented to return \*(L"a list\*(R" return a reference to an array of the
same in scalar context, unless something else is explicitly mentioned.
.ie n .IP """columns""" 14
.el .IP "\f(CWcolumns\fR" 14
.IX Item "columns"
Returns a list of column names. Affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """bind(LIST)""" 14
.el .IP "\f(CWbind(LIST)\fR" 14
.IX Item "bind(LIST)"
Binds the given \s-1LIST\s0 of variables to the columns. Unlike with \s-1DBI\s0's
\&\f(CW\*(C`bind_columns\*(C'\fR, passing references is not needed.
.Sp
Bound variables are very efficient. Binding a tied variable doesn't work.
.ie n .IP """attr(...)""" 14
.el .IP "\f(CWattr(...)\fR" 14
.IX Item "attr(...)"
Returns a copy of an sth attribute (property). See \*(L"Statement Handle
Attributes\*(R" in \s-1DBI\s0 for details.
.ie n .IP """func(...)""" 14
.el .IP "\f(CWfunc(...)\fR" 14
.IX Item "func(...)"
This calls the \f(CW\*(C`func\*(C'\fR method on the sth of \s-1DBI\s0. See \s-1DBI\s0 for details.
.ie n .IP """rows""" 14
.el .IP "\f(CWrows\fR" 14
.IX Item "rows"
Returns the number of rows affected by the last row affecting command, or \-1 if
the number of rows is not known or not available.
.Sp
For \s-1SELECT\s0 statements, it is generally not possible to know how many rows are
returned. MySQL does provide this information. See \s-1DBI\s0 for a detailed
explanation.
.ie n .IP """finish""" 14
.el .IP "\f(CWfinish\fR" 14
.IX Item "finish"
Finishes the statement. After finishing a statement, it can no longer be used.
When the result object is destroyed, its statement handle is automatically
finished and destroyed. There should be no reason to call this method
explicitly; just let the result object go out of scope.
.PP
\fIFetching a single row at a time\fR
.IX Subsection "Fetching a single row at a time"
.ie n .IP """fetch""" 14
.el .IP "\f(CWfetch\fR" 14
.IX Item "fetch"
Returns a reference to the array that holds the values. This is the same array
every time.
.Sp
Subsequent fetches (using any method) may change the values in the variables
passed and the returned reference's array.
.ie n .IP """into(LIST)""" 14
.el .IP "\f(CWinto(LIST)\fR" 14
.IX Item "into(LIST)"
Combines \f(CW\*(C`bind\*(C'\fR with \f(CW\*(C`fetch\*(C'\fR. Returns what \f(CW\*(C`fetch\*(C'\fR returns.
.ie n .IP """list""" 14
.el .IP "\f(CWlist\fR" 14
.IX Item "list"
Returns a list of values, or (in scalar context), only the last value.
.ie n .IP """array""" 14
.el .IP "\f(CWarray\fR" 14
.IX Item "array"
Returns a reference to an array.
.ie n .IP """hash""" 14
.el .IP "\f(CWhash\fR" 14
.IX Item "hash"
Returns a reference to a hash, keyed by column name. Affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """kv_list""" 14
.el .IP "\f(CWkv_list\fR" 14
.IX Item "kv_list"
Returns an ordered list of interleaved keys and values. Affected by
\&\f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """kv_array""" 14
.el .IP "\f(CWkv_array\fR" 14
.IX Item "kv_array"
Returns a reference to an array of interleaved column names and values. Like
kv, but returns an array reference even in list context. Affected by
\&\f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """object($class, ...)""" 14
.el .IP "\f(CWobject($class, ...)\fR" 14
.IX Item "object($class, ...)"
Returns an instance of \f(CW$class\fR. See \*(L"Object construction\*(R". Possibly affected by
\&\f(CW\*(C`lc_columns\*(C'\fR.
.PP
\fIFetching all remaining rows\fR
.IX Subsection "Fetching all remaining rows"
.ie n .IP """flat""" 14
.el .IP "\f(CWflat\fR" 14
.IX Item "flat"
Returns a flattened list.
.ie n .IP """arrays""" 14
.el .IP "\f(CWarrays\fR" 14
.IX Item "arrays"
Returns a list of references to arrays
.ie n .IP """hashes""" 14
.el .IP "\f(CWhashes\fR" 14
.IX Item "hashes"
Returns a list of references to hashes, keyed by column name. Affected by
\&\f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """kv_flat""" 14
.el .IP "\f(CWkv_flat\fR" 14
.IX Item "kv_flat"
Returns an flattened list of interleaved column names and values. Affected by
\&\f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """kv_arrays""" 14
.el .IP "\f(CWkv_arrays\fR" 14
.IX Item "kv_arrays"
Returns a list of references to arrays of interleaved column names and values.
Affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """objects($class, ...)""" 14
.el .IP "\f(CWobjects($class, ...)\fR" 14
.IX Item "objects($class, ...)"
Returns a list of instances of \f(CW$class\fR. See \*(L"Object construction\*(R". Possibly
affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """map_arrays($column_number)""" 14
.el .IP "\f(CWmap_arrays($column_number)\fR" 14
.IX Item "map_arrays($column_number)"
Constructs a hash of array references keyed by the values in the chosen column,
and returns a list of interleaved keys and values, or (in scalar context), a
reference to a hash.
.ie n .IP """map_hashes($column_name)""" 14
.el .IP "\f(CWmap_hashes($column_name)\fR" 14
.IX Item "map_hashes($column_name)"
Constructs a hash of hash references keyed by the values in the chosen column,
and returns a list of interleaved keys and values, or (in scalar context), a
reference to a hash. Affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """map""" 14
.el .IP "\f(CWmap\fR" 14
.IX Item "map"
Constructs a simple hash, using the two columns as key/value pairs. Should
only be used with queries that return two columns. Returns a list of interleaved
keys and values, or (in scalar context), a reference to a hash.
.ie n .IP """xto(%attr)""" 14
.el .IP "\f(CWxto(%attr)\fR" 14
.IX Item "xto(%attr)"
Returns a DBIx::XHTML_Table object, passing the constructor a reference to
\&\f(CW%attr\fR.
.Sp
Requires Jeffrey Hayes Anderson's DBIx::XHTML_Table, which is available from
\&\s-1CPAN\s0.
.Sp
In general, using the \f(CW\*(C`html\*(C'\fR method (described below) is much easier. \f(CW\*(C`xto\*(C'\fR
is available in case you need more flexibility. Not affected by \f(CW\*(C`lc_columns\*(C'\fR.
.ie n .IP """html(%attr)""" 14
.el .IP "\f(CWhtml(%attr)\fR" 14
.IX Item "html(%attr)"
Returns an (X)HTML formatted table, using the DBIx::XHTML_Table module. Passes
a reference to \f(CW%attr\fR to both the constructor and the \f(CW\*(C`output\*(C'\fR method.
.Sp
Requires Jeffrey Hayes Anderson's DBIx::XHTML_Table, which is available from
\&\s-1CPAN\s0.
.Sp
This method is a shortcut method. That means that
.Sp
.Vb 1
\&    $result\->html
\&
\&    $result\->html(
\&        tr => { bgcolor => [ \*(Aqsilver\*(Aq, \*(Aqwhite\*(Aq ] },
\&        no_ucfirst => 1
\&    )
.Ve
.Sp
do the same as:
.Sp
.Vb 1
\&    $result\->xto\->output
\&
\&    $result\->xto(
\&        tr => { bgcolor => [ \*(Aqsilver\*(Aq, \*(Aqwhite\*(Aq ] }
\&    )\->output(
\&        no_ucfirst => 1
\&    );
.Ve
.ie n .IP """text($type)""" 14
.el .IP "\f(CWtext($type)\fR" 14
.IX Item "text($type)"
Returns a string with a simple text representation of the data. \f(CW$type\fR
can be any of: \f(CW\*(C`neat\*(C'\fR, \f(CW\*(C`table\*(C'\fR, \f(CW\*(C`box\*(C'\fR. It defaults to \f(CW\*(C`table\*(C'\fR if
Text::Table is installed, to \f(CW\*(C`neat\*(C'\fR if it isn't.
.Sp
\&\f(CW\*(C`table\*(C'\fR and \f(CW\*(C`box\*(C'\fR require Anno Siegel's Text::Table, which is available from
\&\s-1CPAN\s0.
.SS "Object construction"
.IX Subsection "Object construction"
DBIx::Simple has basic support for returning results as objects. The actual
construction method has to be provided by the chosen class, making this
functionality rather advanced and perhaps unsuited for beginning programmers.
.PP
When the \f(CW\*(C`object\*(C'\fR or \f(CW\*(C`objects\*(C'\fR method is called on the result object returned
by one of the query methods, two approaches are tried. In either case, pass the
name of a class as the first argument. A prefix of a single colon can be used
as an alias for \f(CW\*(C`DBIx::Simple::Result::\*(C'\fR, e.g. \f(CW":Example"\fR is short for
\&\f(CW"DBIx::Simple::Result::Example"\fR. When this shortcut is used, the
corresponding module is loaded automatically.
.PP
The default class when no class is given, is \f(CW\*(C`:RowObject\*(C'\fR. It requires Jos
Boumans' Object::Accessor, which is available from \s-1CPAN\s0.
.PP
\fISimple object construction\fR
.IX Subsection "Simple object construction"
.PP
When \f(CW\*(C`object\*(C'\fR is given a class that provides a \f(CW\*(C`new\*(C'\fR method, but not a
\&\f(CW\*(C`new_from_dbix_simple\*(C'\fR method, \f(CW\*(C`new\*(C'\fR is called with a list of interleaved
column names and values, like a flattened hash, but ordered. \f(CW\*(C`objects\*(C'\fR causes
\&\f(CW\*(C`new\*(C'\fR to be called multiple times, once for each remaining row.
.PP
Example:
.PP
.Vb 6
\&    {
\&        package DBIx::Simple::Result::ObjectExample;
\&        sub new {
\&            my ($class, %args) = @_;
\&            return bless $class, \e%args;
\&        }
\&
\&        sub foo { ... }
\&        sub bar { ... }
\&    }
\&
\&
\&    $db\->query(\*(AqSELECT foo, bar FROM baz\*(Aq)\->object(\*(Aq:ObjectExample\*(Aq)\->foo();
.Ve
.PP
\fIAdvanced object construction\fR
.IX Subsection "Advanced object construction"
.PP
When \f(CW\*(C`object\*(C'\fR or \f(CW\*(C`objects\*(C'\fR is given a class that provides a
\&\f(CW\*(C`new_from_dbix_simple\*(C'\fR method, any \f(CW\*(C`new\*(C'\fR is ignored, and
\&\f(CW\*(C`new_from_dbix_simple\*(C'\fR is called with a list of the DBIx::Simple::Result
object and any arguments passed to \f(CW\*(C`object\*(C'\fR or \f(CW\*(C`objects\*(C'\fR.
.PP
\&\f(CW\*(C`new_from_dbix_simple\*(C'\fR is called in scalar context for \f(CW\*(C`object\*(C'\fR, and in list
context for \f(CW\*(C`objects\*(C'\fR. In scalar context, it should fetch \fIexactly one row\fR,
and in list context, it should fetch \fIall remaining rows\fR.
.PP
Example:
.PP
.Vb 7
\&    {
\&        package DBIx::Simple::Result::ObjectExample;
\&        sub new_from_dbix_simple {
\&            my ($class, $result, @args) = @_;
\&            return map { bless $class, $_ } $result\->hashes if wantarray;
\&            return       bless $class, $result\->hash;
\&        }
\&
\&        sub foo { ... }
\&        sub bar { ... }
\&    }
\&
\&    $db\->query(\*(AqSELECT foo, bar FROM baz\*(Aq)\->object(\*(Aq:ObjectExample\*(Aq)\->foo();
.Ve
.SH "MISCELLANEOUS"
.IX Header "MISCELLANEOUS"
The mapping methods do not check whether the keys are unique. Rows that are
fetched later overwrite earlier ones.
.SH "LICENSE"
.IX Header "LICENSE"
Pick your favourite \s-1OSI\s0 approved license :)
.PP
http://www.opensource.org/licenses/alphabetical
.SH "AUTHOR"
.IX Header "AUTHOR"
Juerd Waalboer <#####@juerd.nl> <http://juerd.nl/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl, perlref
.PP
\&\s-1DBI\s0, DBIx::Simple::Examples, SQL::Abstract, DBIx::XHTML_Table
