.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "MongoDB::Cursor 3"
.TH MongoDB::Cursor 3 "2013-08-27" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
MongoDB::Cursor \- A cursor/iterator for Mongo query results
.SH "VERSION"
.IX Header "VERSION"
version 0.702.2
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    while (my $object = $cursor\->next) {
\&        ...
\&    }
\&
\&    my @objects = $cursor\->all;
.Ve
.SS "Multithreading"
.IX Subsection "Multithreading"
Cloning instances of this class is disabled in Perl 5.8.7+, so forked threads
will have to create their own database queries.
.SH "NAME"
MongoDB::Cursor \- A cursor/iterator for Mongo query results
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Core documentation on cursors: <http://dochub.mongodb.org/core/cursors>.
.SH "STATIC ATTRIBUTES"
.IX Header "STATIC ATTRIBUTES"
.SS "slave_okay"
.IX Subsection "slave_okay"
.Vb 1
\&    $MongoDB::Cursor::slave_okay = 1;
.Ve
.PP
Whether it is okay to run queries on the slave.  Defaults to 0.
.SS "timeout"
.IX Subsection "timeout"
\&\fBDeprecated, use MongoDB::Connection::query_timeout instead.\fR
.PP
How many milliseconds to wait for a response from the server.  Set to 30000
(30 seconds) by default.  \-1 waits forever (or until \s-1TCP\s0 times out, which is
usually a long time).
.PP
This value is overridden by \f(CW\*(C`MongoDB::Connection::query_timeout\*(C'\fR and never
used.
.SH "ATTRIBUTES"
.IX Header "ATTRIBUTES"
.SS "started_iterating"
.IX Subsection "started_iterating"
If this cursor has queried the database yet. Methods
mofifying the query will complain if they are called
after the database is queried.
.SS "immortal"
.IX Subsection "immortal"
.Vb 1
\&    $cursor\->immortal(1);
.Ve
.PP
Ordinarily, a cursor \*(L"dies\*(R" on the database server after a certain length of
time (approximately 10 minutes), to prevent inactive cursors from hogging
resources.  This option sets that a cursor should not die until all of its
results have been fetched or it goes out of scope in Perl.
.PP
Boolean value, defaults to 0.
.PP
\&\f(CW\*(C`immortal\*(C'\fR is not equivalent to setting a client-side timeout.  If you are
getting client-side timeouts (e.g., \*(L"recv timed out\*(R"), set \f(CW\*(C`query_timeout\*(C'\fR on
your connection.
.PP
.Vb 2
\&    # wait forever for a query to return results
\&    $connection\->query_timeout(\-1);
.Ve
.PP
See \*(L"query_timeout\*(R" in MongoDB::Connection.
.SS "partial"
.IX Subsection "partial"
If a shard is down, mongos will return an error when it tries to query that
shard.  If this is set, mongos will just skip that shard, instead.
.PP
Boolean value, defaults to 0.
.SS "slave_okay"
.IX Subsection "slave_okay"
.Vb 1
\&    $cursor\->slave_okay(1);
.Ve
.PP
If a query can be done on a slave database server.
.PP
Boolean value, defaults to 0.
.SH "METHODS"
.IX Header "METHODS"
.SS "fields (\e%f)"
.IX Subsection "fields (%f)"
.Vb 5
\&    $coll\->insert({name => "Fred", age => 20});
\&    my $cursor = $coll\->query\->fields({ name => 1 });
\&    my $obj = $cursor\->next;
\&    $obj\->{name}; "Fred"
\&    $obj\->{age}; # undef
.Ve
.PP
Selects which fields are returned.
The default is all fields.  _id is always returned.
.SS "sort ($order)"
.IX Subsection "sort ($order)"
.Vb 3
\&    # sort by name, descending
\&    my $sort = {"name" => \-1};
\&    $cursor = $coll\->query\->sort($sort);
.Ve
.PP
Adds a sort to the query.  Argument is either
a hash reference or a Tie::IxHash.
Returns this cursor for chaining operations.
.SS "limit ($num)"
.IX Subsection "limit ($num)"
.Vb 2
\&    $per_page = 20;
\&    $cursor = $coll\->query\->limit($per_page);
.Ve
.PP
Returns a maximum of N results.
Returns this cursor for chaining operations.
.SS "tailable ($bool)"
.IX Subsection "tailable ($bool)"
.Vb 1
\&    $cursor\->query\->tailable(1);
.Ve
.PP
If a cursor should be tailable.  Tailable cursors can only be used on capped
collections and are similar to the \f(CW\*(C`tail \-f\*(C'\fR command: they never die and keep
returning new results as more is added to a collection.
.PP
They are often used for getting log messages.
.PP
Boolean value, defaults to 0.
.PP
Returns this cursor for chaining operations.
.SS "skip ($num)"
.IX Subsection "skip ($num)"
.Vb 3
\&    $page_num = 7;
\&    $per_page = 100;
\&    $cursor = $coll\->query\->limit($per_page)\->skip($page_num * $per_page);
.Ve
.PP
Skips the first N results. Returns this cursor for chaining operations.
.PP
See also core documentation on limit: <http://dochub.mongodb.org/core/limit>.
.SS "snapshot"
.IX Subsection "snapshot"
.Vb 1
\&    my $cursor = $coll\->query\->snapshot;
.Ve
.PP
Uses snapshot mode for the query.  Snapshot mode assures no
duplicates are returned, or objects missed, which were present
at both the start and end of the query's execution (if an object
is new during the query, or deleted during the query, it may or
may not be returned, even with snapshot mode).  Note that short
query responses (less than 1MB) are always effectively
snapshotted.  Currently, snapshot mode may not be used with
sorting or explicit hints.
.SS "hint"
.IX Subsection "hint"
.Vb 1
\&    my $cursor = $coll\->query\->hint({\*(Aqx\*(Aq => 1});
.Ve
.PP
Force Mongo to use a specific index for a query.
.SS "explain"
.IX Subsection "explain"
.Vb 1
\&    my $explanation = $cursor\->explain;
.Ve
.PP
This will tell you the type of cursor used, the number of records the \s-1DB\s0 had to
examine as part of this query, the number of records returned by the query, and
the time in milliseconds the query took to execute.  Requires boolean package.
.PP
\&\f(CW\*(C`explain\*(C'\fR resets the cursor, so calling \f(CW\*(C`next\*(C'\fR or \f(CW\*(C`has_next\*(C'\fR after an explain
will requery the database.
.PP
See also core documentation on explain:
<http://dochub.mongodb.org/core/explain>.
.SS "count($all?)"
.IX Subsection "count($all?)"
.Vb 2
\&    my $num = $cursor\->count;
\&    my $num = $cursor\->skip(20)\->count(1);
.Ve
.PP
Returns the number of document this query will return.  Optionally takes a
boolean parameter, indicating that the cursor's limit and skip fields should be
used in calculating the count.
.SS "reset"
.IX Subsection "reset"
Resets the cursor.  After being reset, pre-query methods can be
called on the cursor (sort, limit, etc.) and subsequent calls to
next, has_next, or all will re-query the database.
.SS "has_next"
.IX Subsection "has_next"
.Vb 3
\&    while ($cursor\->has_next) {
\&        ...
\&    }
.Ve
.PP
Checks if there is another result to fetch.
.SS "next"
.IX Subsection "next"
.Vb 3
\&    while (my $object = $cursor\->next) {
\&        ...
\&    }
.Ve
.PP
Returns the next object in the cursor. Will automatically fetch more data from
the server if necessary. Returns undef if no more data is available.
.SS "info"
.IX Subsection "info"
Returns a hash of information about this cursor.  Currently the fields are:
.ie n .IP """cursor_id""" 4
.el .IP "\f(CWcursor_id\fR" 4
.IX Item "cursor_id"
The server-side id for this cursor.  A \f(CW\*(C`cursor_id\*(C'\fR of 0 means that there are no
more batches to be fetched.
.ie n .IP """num""" 4
.el .IP "\f(CWnum\fR" 4
.IX Item "num"
The number of results returned so far.
.ie n .IP """at""" 4
.el .IP "\f(CWat\fR" 4
.IX Item "at"
The index of the result the cursor is currently at.
.ie n .IP """flag""" 4
.el .IP "\f(CWflag\fR" 4
.IX Item "flag"
If the database could not find the cursor or another error occurred, \f(CW\*(C`flag\*(C'\fR may
be set (depending on the error).
See http://www.mongodb.org/display/DOCS/Mongo+Wire+Protocol#MongoWireProtocol\-OPREPLY <http://www.mongodb.org/display/DOCS/Mongo+Wire+Protocol#MongoWireProtocol-OPREPLY>
for a full list of flag values.
.ie n .IP """start""" 4
.el .IP "\f(CWstart\fR" 4
.IX Item "start"
The index of the result that the current batch of results starts at.
.SS "all"
.IX Subsection "all"
.Vb 1
\&    my @objects = $cursor\->all;
.Ve
.PP
Returns a list of all objects in the result.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 1
\&  Kristina Chodorow <kristina@mongodb.org>
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
.IP "\(bu" 4
Florian Ragwitz <rafl@debian.org>
.IP "\(bu" 4
Kristina Chodorow <kristina@mongodb.org>
.IP "\(bu" 4
Mike Friedman <friedo@mongodb.com>
.SH "COPYRIGHT AND LICENSE"
.IX Header "COPYRIGHT AND LICENSE"
This software is Copyright (c) 2013 by MongoDB, Inc..
.PP
This is free software, licensed under:
.PP
.Vb 1
\&  The Apache License, Version 2.0, January 2004
.Ve
