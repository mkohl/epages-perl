.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Git::Repository::Tutorial 3"
.TH Git::Repository::Tutorial 3 "2015-07-29" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Git::Repository::Tutorial \- Control git from Perl using Git::Repository
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Git::Repository;
\&
\&    # do cool stuff with Git, using the following advice
.Ve
.SH "HOW-TO"
.IX Header "HOW-TO"
A Git::Repository object represents an actual Git repository,
against which you can \fIrun\fR commands.
.SS "Obtain a Git::Repository object from an existing repository"
.IX Subsection "Obtain a Git::Repository object from an existing repository"
If your script is expected to run against a repository in the current
directory (like most Git commands), let Git::Repository handle
the magic:
.PP
.Vb 1
\&    $r = Git::Repository\->new();
.Ve
.PP
If the repository has a working copy (work tree):
.PP
.Vb 1
\&    $r = Git::Repository\->new( work_tree => $dir );
.Ve
.PP
If the repository is a bare repository, or you prefer to provide
the \fI.git\fR directory location:
.PP
.Vb 1
\&    $r = Git::Repository\->new( git_dir => $gitdir );
.Ve
.PP
If the work tree and the git directory are in unrelated locations,
you can also provide both:
.PP
.Vb 1
\&    $r = Git::Repository\->new( work_tree => $dir, git_dir => $gitdir );
.Ve
.PP
The constructor also accepts an option hash. The various options
are detailed in the manual page for Git::Repository::Command.
.SS "Run any git command"
.IX Subsection "Run any git command"
Git commands can be run against an existing Git::Repository object,
or against the class itself (in which case, git will try to deduce its
context from the current directory and the environment).
.PP
The pattern for running commands is always the same:
.PP
.Vb 1
\&    $r\->run( $command => @arguments, \e%options );
.Ve
.PP
The \f(CW$command\fR and \f(CW@arguments\fR are identical to those you'd pass to
the \f(CW\*(C`git\*(C'\fR command-line tool. The options hash contains options, as
described in the manual page for Git::Repository::Command.
.SS "Create a new repository"
.IX Subsection "Create a new repository"
Sometime, you'll need to create the Git repository from scratch:
.PP
.Vb 3
\&    # git version 1.6.5 and above
\&    Git::Repository\->run( init => $dir );
\&    $r = Git::Repository\->new( work_tree => $dir );
.Ve
.PP
Any git older than 1.6.5 requires the command to be run in the work tree,
so we use the \f(CW\*(C`cwd\*(C'\fR option:
.PP
.Vb 3
\&    # git version 1.5.0.rc1 and above
\&    Git::Repository\->run( init => { cwd => $dir } );
\&    $r = Git::Repository\->new( work_tree => $dir );
\&
\&    # older git versions
\&    Git::Repository\->run( \*(Aqinit\-db\*(Aq => { cwd => $dir } );
\&    $r = Git::Repository\->new( work_tree => $dir );
.Ve
.PP
Note that the old \f(CW\*(C`create()\*(C'\fR method
is obsolete (as of Git::Repository 1.18, from April 16, 2011)
and has been removed (as of Git::Repository 1.301, January 21, 2013).
.SS "Clone a repository"
.IX Subsection "Clone a repository"
Cloning works the same way:
.PP
.Vb 2
\&    Git::Repository\->run( clone => $url => $dir );
\&    $r = Git::Repository\->new( work_tree => $dir );
.Ve
.SS "Run a simple command"
.IX Subsection "Run a simple command"
When you don't really care about the output of the command, just call
it:
.PP
.Vb 2
\&    $r\->run( add => \*(Aq.\*(Aq );
\&    $r\->run( commit => \*(Aq\-m\*(Aq, \*(Aqmy commit message\*(Aq );
.Ve
.PP
In case of an error or warning, Git::Repository will \f(CW\*(C`croak()\*(C'\fR or
\&\f(CW\*(C`carp()\*(C'\fR appropriately.
.SS "Properly quote options"
.IX Subsection "Properly quote options"
It's common to work out the proper string of Git commands needed to
achieve your goal in the shell, before actually turning them into calls
to \f(CW\*(C`Git::Repository\->run\*(C'\fR.
.PP
Some options might require quoting, to properly get the arguments to
Git through the shell:
.PP
.Vb 2
\&    # shell
\&    $ git log \-\-since=\*(AqFri Jul 26 19:34:15 2013 +0200\*(Aq \-\-grep=\*(Aqreport ticket\*(Aq
.Ve
.PP
Such quoting is of course not needed with Git::Repository:
.PP
.Vb 3
\&    $since = \*(AqFri Jul 26 19:34:15 2013 +0200\*(Aq;
\&    $grep  = \*(Aqreport ticket\*(Aq;
\&    my $cmd = $r\->command( log => "\-\-since=$since", "\-\-grep=$grep" );
.Ve
.SS "Silence warnings for some Git commands"
.IX Subsection "Silence warnings for some Git commands"
Some Git porcelain commands provide additional information on \f(CW\*(C`STDERR\*(C'\fR.
One typical example is \f(CW\*(C`git checkout\*(C'\fR:
.PP
.Vb 2
\&    $ git checkout mybranch
\&    Switched to branch \*(Aqmybranch\*(Aq
.Ve
.PP
The \f(CW\*(C`run()\*(C'\fR method of Git::Repository treats all output on \f(CW\*(C`STDERR\*(C'\fR
as a warning. Therefore, the following code:
.PP
.Vb 1
\&    $r\->run( checkout => \*(Aqmybranch\*(Aq );
.Ve
.PP
will output a warning like this one:
.PP
.Vb 1
\&    Switched to branch \*(Aqmybranch\*(Aq at myscript.pl line 10.
.Ve
.PP
In such a case, you can use the \f(CW\*(C`quiet\*(C'\fR option to silence the warning
for a single command:
.PP
.Vb 1
\&    $r\->run( checkout => \*(Aqmybranch\*(Aq, { quiet => 1 } );
.Ve
.PP
To silence \fIall\fR warnings, you can pass the \f(CW\*(C`quiet\*(C'\fR option during the
creation of the original repository object:
.PP
.Vb 1
\&    my $r = Git::Repository\->new( { quiet => 1 } );
.Ve
.PP
This is not recommended, as it might hide important information from you.
.SS "Process normal and error output"
.IX Subsection "Process normal and error output"
The \f(CW\*(C`run()\*(C'\fR command doesn't capture \f(CW\*(C`STDERR\*(C'\fR: it only warns (or dies)
if something was printed on it. To be able to actually capture error
output, \f(CW\*(C`command()\*(C'\fR must be used.
.PP
.Vb 3
\&    my $cmd = $r\->command( @cmd );
\&    my @errput = $cmd\->stderr\->getlines();
\&    $cmd\->close;
.Ve
.PP
\&\f(CW\*(C`run()\*(C'\fR also captures all output at once, which can lead to unnecessary
memory consumption when capturing the output of some really verbose
commands.
.PP
.Vb 6
\&    my $cmd = $r\->command( log => \*(Aq\-\-pretty=oneline\*(Aq, \*(Aq\-\-all\*(Aq );
\&    my $log = $cmd\->stdout;
\&    while (<$log>) {
\&        ...;
\&    }
\&    $cmd\->close;
.Ve
.PP
Of course, as soon as one starts reading and writing to an external
process' communication handles, a risk of blocking exists.
\&\fICaveat emptor\fR.
.SS "Provide input on standard input"
.IX Subsection "Provide input on standard input"
Use the \f(CW\*(C`input\*(C'\fR option:
.PP
.Vb 2
\&    my $commit = $r\->run( \*(Aqcommit\-tree\*(Aq, $tree, \*(Aq\-p\*(Aq, $parent,
\&        { input => $message } );
.Ve
.SS "Change the environment of a command"
.IX Subsection "Change the environment of a command"
Use the \f(CW\*(C`env\*(C'\fR option:
.PP
.Vb 8
\&    $r\->run(
\&        \*(Aqcommit\*(Aq, \*(Aq\-m\*(Aq, \*(Aqlog message\*(Aq,
\&        {   env => {
\&                GIT_COMMITTER_NAME  => \*(AqGit::Repository\*(Aq,
\&                GIT_COMMITTER_EMAIL => \*(Aqbook@cpan.org\*(Aq,
\&            },
\&        },
\&    );
.Ve
.PP
See Git::Repository::Command for other available options.
.SS "Ensure the output from Git commands is not localized"
.IX Subsection "Ensure the output from Git commands is not localized"
Since version 1.7.9, Git translates its most common interface messages
into the user's language if translations are available and the
locale is appropriately set.
.PP
This means that naively parsing the output \*(L"porcelain\*(R" commands might
fail if the program is unexpectedly run under an unexpected locale.
.PP
The easiest way to ensure your Git commands will be run in a \*(L"locale-safe\*(R"
environment, is to set the \f(CW\*(C`LC_ALL\*(C'\fR environment variable to \f(CW\*(C`C\*(C'\fR.
.PP
The brutal way:
.PP
.Vb 1
\&    $ENV{LC_ALL} = \*(AqC\*(Aq;
.Ve
.PP
The temporary way:
.PP
.Vb 1
\&    local $ENV{LC_ALL} = \*(AqC\*(Aq;
.Ve
.PP
The subtle way (restricted to the commands run on a given Git::Repository
instance):
.PP
.Vb 1
\&    my $r = Git::Repository\->new( { env => { LC_ALL => \*(AqC\*(Aq } } );
.Ve
.PP
The stealthiest way (restricted to a single command):
.PP
.Vb 1
\&    $r\->run( ..., { env => { LC_ALL => \*(AqC\*(Aq } } );
.Ve
.SS "Ensure the Git commands are run from the current working directory"
.IX Subsection "Ensure the Git commands are run from the current working directory"
By default, Git::Repository::Command will \f(CW\*(C`chdir()\*(C'\fR to the root of
the work tree before launching the requested Git command.
.PP
This means that no matter where your program \f(CW\*(C`chdir()\*(C'\fR to, commands on
the Git::Repository instance will by default be run from the root of
the work tree. So, commands such as \f(CW\*(C`add\*(C'\fR need to use the \*(L"full\*(R" path
(relative to \f(CW\*(C`GIT_WORK_TREE\*(C'\fR) of the files to be added.
.PP
The \f(CW\*(C`cwd\*(C'\fR option can be used to define where Git::Repository::Command will
\&\f(CW\*(C`chdir()\*(C'\fR to. To instruct Git::Repository::Command to \fBnot\fR \f(CW\*(C`chdir()\*(C'\fR
(and therefore run the Git command from the \fIcurrent working directory\fR),
set the option to \f(CW\*(C`undef\*(C'\fR:
.PP
.Vb 2
\&    # run from cwd for this command only
\&    $r\->run( ..., { cwd => undef } );
\&
\&    # always run git from cwd
\&    my $r = Git::Repository\->new( { cwd => undef } );
.Ve
.ie n .SS "Finely control when ""run()"" dies"
.el .SS "Finely control when \f(CWrun()\fP dies"
.IX Subsection "Finely control when run() dies"
By default, \f(CW\*(C`Git::Repository\->run( ... )\*(C'\fR dies if the Git
command exited with a status code of \f(CW128\fR (fatal error)
or \f(CW129\fR (usage message).
.PP
Some commands will throw an error and exit with a status different
from the previous two:
.PP
.Vb 1
\&    $r\->run( checkout => \*(Aqdoes\-not\-exist\*(Aq );    # exit status: 1
.Ve
.PP
The above \f(CW\*(C`run()\*(C'\fR call does not die, and output the following warning:
.PP
.Vb 1
\&    error: pathspec \*(Aqdoes\-not\-exist\*(Aq did not match any file(s) known to git.
.Ve
.PP
The exit status (as given by \f(CW\*(C`$? >> 8\*(C'\fR) is \f(CW1\fR.
.PP
To force \f(CW\*(C`run()\*(C'\fR to die when the Git command exits with status \f(CW1\fR,
use the \f(CW\*(C`fatal\*(C'\fR option (added in version 1.304, May 25, 2013):
.PP
.Vb 1
\&    $r\->run( checkout => \*(Aqdoes\-not\-exist\*(Aq, { fatal => 1 } );
.Ve
.PP
By default, \f(CW128\fR and \f(CW129\fR remain in the list of fatal codes.
.PP
Here are a few examples:
.PP
.Vb 2
\&    # set the fatal codes for all call to run() on this object
\&    $r = Git::Repository\->new( { fatal => [ 1 .. 255 ] } );
.Ve
.PP
As usual, setting the option to the Git::Repository object will set
it for all commands run for it:
.PP
.Vb 2
\&    # "!0" is a shortcut for 1 .. 255
\&    $r = Git::Repository\->new( { fatal => [ "!0" ] } );
.Ve
.PP
Using negative codes will make these values non-fatal:
.PP
.Vb 3
\&    # the above call to new() makes all exit codes fatal
\&    # but 3 and 7 won\*(Aqt be fatal for this specific run
\&    $r\->run( ..., { fatal => [ \-3, \-7 ] } );
.Ve
.PP
When the list contains a single item, there is no need to use an array
reference:
.PP
.Vb 2
\&    # same as [ "!0" ]
\&    $r = Git::Repository\->new( { fatal => "!0" } );
\&
\&    # remove 17 from the list of fatal exit codes for this run only
\&    $r\->run( ..., { fatal => \-17 } );
.Ve
.PP
See Git::Repository::Command for other available options.
.SS "Process the output of \fBgit log\fP"
.IX Subsection "Process the output of git log"
When creating a tool that needs to process the output of \fBgit log\fR,
you should always define precisely the expected format using the
\&\fI\-\-pretty\fR option, and choose a format that is easy to parse.
.PP
Assuming \fBgit log\fR will output the default format will eventually
lead to problems, for example when the user's git configuration defines
\&\f(CW\*(C`format.pretty\*(C'\fR to be something else than the default of \f(CW\*(C`medium\*(C'\fR.
.PP
See also Git::Repository::Plugin::Log for adding to your
Git::Repository objects a \f(CW\*(C`log()\*(C'\fR method that will parse the log
output for you.
.SS "Process the output of \fBgit shortlog\fP"
.IX Subsection "Process the output of git shortlog"
\&\fBgit shortlog\fR behaves differently when it detects it's not attached
to a terminal. In that case, it just tries to read some \fBgit log\fR
output from its standard input.
.PP
So this oneliner will hang, because \fBgit shortlog\fR is waiting for some
data from the program connected to its standard input (the oneliner):
.PP
.Vb 1
\&    perl \-MGit::Repository \-le \*(Aqprint scalar Git::Repository\->run( shortlog => \-5 )\*(Aq
.Ve
.PP
Whereas this one will \*(L"work\*(R" (as in \*(L"immediately return with no output\*(R"):
.PP
.Vb 1
\&    perl \-MGit::Repository \-le \*(Aqprint scalar Git::Repository\->run( shortlog => \-5, { input => "" } )\*(Aq
.Ve
.PP
So, you need to give \fBgit shortlog\fR \fIsome\fR input (from \fBgit log\fR):
.PP
.Vb 1
\&    perl \-MGit::Repository \-le \*(Aqprint scalar Git::Repository\->run( shortlog => { input => scalar Git::Repository\->run( log => \-5 ) } )\*(Aq
.Ve
.PP
If the log output is large, you'll probably be better off with something
like the following:
.PP
.Vb 1
\&    use Git::Repository;
\&
\&    # start both git commands
\&    my $log = Git::Repository\->command(\*(Aqlog\*(Aq)\->stdout;
\&    my $cmd = Git::Repository\->command( shortlog => \-ens );
\&
\&    # feed one with the output of the other
\&    my $in = $cmd\->stdin;
\&    print {$in} $_ while <$log>;
\&    close $in;
\&
\&    # and do something with the output
\&    print $cmd\->stdout\->getlines;
.Ve
.SS "Wrap git in a sudo call"
.IX Subsection "Wrap git in a sudo call"
If for a given repository you want to wrap all calls to git in a \f(CW\*(C`sudo\*(C'\fR
call, you can use the \f(CW\*(C`git\*(C'\fR option with an array ref:
.PP
.Vb 1
\&    my $r = Git::Repository\->new( { git => [qw( sudo \-u nobody git )] } );
.Ve
.PP
In this case, every call to git from \f(CW$r\fR will actually call
\&\f(CW\*(C`sudo \-u nobody git\*(C'\fR.
.SS "Use submodules"
.IX Subsection "Use submodules"
Because Git::Repository automatically sets the \f(CW\*(C`GIT_DIR\*(C'\fR and
\&\f(CW\*(C`GIT_WORK_TREE\*(C'\fR environment variables, some \f(CW\*(C`submodule\*(C'\fR sub-commands
may fail. For example:
.PP
.Vb 1
\&    $r\->run( submodule => add => $repository => \*(Aqsub\*(Aq );
.Ve
.PP
will give the following error:
.PP
.Vb 1
\&    error: pathspec \*(Aqsub\*(Aq did not match any file(s) known to git.
.Ve
.PP
To avoid this error, you should enforce the removal of the \f(CW\*(C`GIT_WORK_TREE\*(C'\fR
variable from the environment in which the command is run:
.PP
.Vb 4
\&    $r\->run(
\&        submodule => add => $repository => \*(Aqsub\*(Aq,
\&        { env => { GIT_WORK_TREE => undef } }
\&    );
.Ve
.PP
Note that System::Command version 1.04 is required to be able to remove
variables from the environment.
.SS "Sort git versions"
.IX Subsection "Sort git versions"
Basically, you need to recreate the \f(CW\*(C`cmp\*(C'\fR operator for Git versions,
using the \fIprivate\fR \f(CW\*(C`_version_gt()\*(C'\fR method (which accepts two parameters):
.PP
.Vb 4
\&    @sorted_versions = sort {
\&        Git::Repository::_version_gt( $a, $b )
\&            || \-Git::Repository::_version_gt( $b, $a )
\&    } @versions;
.Ve
.SS "Add specialized methods to your Git::Repository objects"
.IX Subsection "Add specialized methods to your Git::Repository objects"
Have a look at Git::Repository::Plugin and Git::Repository::Plugin::Log,
to learn how to add your own methods to Git::Repository.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010\-2015 Philippe Bruhat (BooK), all rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
