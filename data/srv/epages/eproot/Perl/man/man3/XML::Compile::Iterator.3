.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "XML::Compile::Iterator 3"
.TH XML::Compile::Iterator 3 "2016-09-19" "perl v5.12.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
XML::Compile::Iterator \- reduce view on a node tree
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
It would have been nice to be able to use XML::LibXML::Iterator, but
on the moment of this writing, that module is not maintained.  Besides,
this implementation of the iterator is more specific for our purpose.
The main user for this object currently is XML::Compile::Translate.
.SH "METHODS"
.IX Header "METHODS"
.SS "Constructors"
.IX Subsection "Constructors"
.ie n .IP "$obj\->\fBdescend\fR( [$node, [$path, [$filter]]] )" 4
.el .IP "\f(CW$obj\fR\->\fBdescend\fR( [$node, [$path, [$filter]]] )" 4
.IX Item "$obj->descend( [$node, [$path, [$filter]]] )"
The \f(CW$node\fR is a child of the node handled by the iterator where this
method is called upon.  Without explicit \f(CW$node\fR, the current node is used.
Returned is a new XML::Compile::Iterator object.  The new iterator
will use the same \f(CW$filter\fR as the parent iterator by default.  The internal
administered path with be extended with the \f(CW$path\fR.
.ie n .IP "XML::Compile::Iterator\->\fBnew\fR($node, $path, $filter,)" 4
.el .IP "XML::Compile::Iterator\->\fBnew\fR($node, \f(CW$path\fR, \f(CW$filter\fR,)" 4
.IX Item "XML::Compile::Iterator->new($node, $path, $filter,)"
The \f(CW$node\fR is a XML::LibXML::Node object, of which the direct children
are inspected.
.Sp
The \f(CW$filter\fR a \s-1CODE\s0 reference which is called for each child node.
The only parameter is the parent \f(CW$node\fR, and then it must return
either true or false.  In case of true, the node is selected.
The \s-1FILTERS\s0 is applied to all children of the \f(CW$node\fR once, when the
first child is requested by the program.
.SS "Attributes"
.IX Subsection "Attributes"
.ie n .IP "$obj\->\fBfilter\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfilter\fR()" 4
.IX Item "$obj->filter()"
Returns the \s-1CODE\s0 reference which is used to select the nodes.
.ie n .IP "$obj\->\fBnode\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnode\fR()" 4
.IX Item "$obj->node()"
Returns the XML::LibXML::Node node of which the children are walked
through.
.ie n .IP "$obj\->\fBpath\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBpath\fR()" 4
.IX Item "$obj->path()"
The path represents the location where the node is, like a symbolic
link, how you got there.
.SS "Scanning"
.IX Subsection "Scanning"
.ie n .IP "$obj\->\fBchilds\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBchilds\fR()" 4
.IX Item "$obj->childs()"
Returns the child nodes which fulfil the filter requirements.  In \s-1LIST\s0
context as list, in \s-1SCALAR\s0 context as reference to an \s-1ARRAY\s0.
.ie n .IP "$obj\->\fBcurrentChild\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcurrentChild\fR()" 4
.IX Item "$obj->currentChild()"
Returns the current child node.
.ie n .IP "$obj\->\fBfirstChild\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBfirstChild\fR()" 4
.IX Item "$obj->firstChild()"
Returns the first child node.  Does not change the current position.
.ie n .IP "$obj\->\fBlastChild\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBlastChild\fR()" 4
.IX Item "$obj->lastChild()"
Returns the last child node which fulfills the requirements.
Does not change the current position.
.ie n .IP "$obj\->\fBnextChild\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnextChild\fR()" 4
.IX Item "$obj->nextChild()"
Returns the next child when available, otherwise \f(CW\*(C`undef\*(C'\fR.
.ie n .IP "$obj\->\fBnrChildren\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnrChildren\fR()" 4
.IX Item "$obj->nrChildren()"
Returns the number of childnodes which fulfill the restriction.
.ie n .IP "$obj\->\fBpreviousChild\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBpreviousChild\fR()" 4
.IX Item "$obj->previousChild()"
Returns the previous child when available, otherwise \f(CW\*(C`undef\*(C'\fR.
.SS "simplify \s-1XML\s0 node access"
.IX Subsection "simplify XML node access"
.ie n .IP "$obj\->\fBcurrentContent\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcurrentContent\fR()" 4
.IX Item "$obj->currentContent()"
Returns the textContent of the \fIcurrentChild()\fR node, or undef.
.ie n .IP "$obj\->\fBcurrentLocal\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcurrentLocal\fR()" 4
.IX Item "$obj->currentLocal()"
Returns the local name of the \fIcurrentChild()\fR, or the empty string.
.ie n .IP "$obj\->\fBcurrentType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBcurrentType\fR()" 4
.IX Item "$obj->currentType()"
Returns the type of the \fIcurrentChild()\fR, or the empty string.
.ie n .IP "$obj\->\fBnodeLocal\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnodeLocal\fR()" 4
.IX Item "$obj->nodeLocal()"
Returns the local name of the \fInode()\fR, or the empty string.
.ie n .IP "$obj\->\fBnodeNil\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnodeNil\fR()" 4
.IX Item "$obj->nodeNil()"
Returns true if the current node has \f(CW\*(C`xsi:type="true"\*(C'\fR.
.ie n .IP "$obj\->\fBnodeType\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBnodeType\fR()" 4
.IX Item "$obj->nodeType()"
Returns the type of the \fInode()\fR, or the empty string.
.ie n .IP "$obj\->\fBtextContent\fR()" 4
.el .IP "\f(CW$obj\fR\->\fBtextContent\fR()" 4
.IX Item "$obj->textContent()"
Returns the textContent of the \fInode()\fR, or undef.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
This module is part of XML-Compile distribution version 1.54,
built on September 19, 2016. Website: \fIhttp://perl.overmeer.net/xml\-compile/\fR
.PP
Please post questions or ideas to the mailinglist at
\&\fIhttp://lists.scsys.co.uk/cgi\-bin/mailman/listinfo/xml\-compile\fR .
For live contact with other developers, visit the \f(CW\*(C`#xml\-compile\*(C'\fR channel
on \f(CW\*(C`irc.perl.org\*(C'\fR.
.SH "LICENSE"
.IX Header "LICENSE"
Copyrights 2006\-2016 by [Mark Overmeer]. For other contributors see ChangeLog.
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
See \fIhttp://www.perl.com/perl/misc/Artistic.html\fR
